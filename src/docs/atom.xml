<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Henry 기술블로그</title>
  
  
  <link href="/guriOH.github.io/atom.xml" rel="self"/>
  
  <link href="https://gurioh.github.io/guriOH.github.io/"/>
  <updated>2019-12-17T11:54:24.555Z</updated>
  <id>https://gurioh.github.io/guriOH.github.io/</id>
  
  <author>
    <name>Henry Oh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>build location</title>
    <link href="https://gurioh.github.io/guriOH.github.io/build%20location/"/>
    <id>https://gurioh.github.io/guriOH.github.io/build location/</id>
    <published>2019-12-17T11:54:24.555Z</published>
    <updated>2019-12-17T11:54:24.555Z</updated>
    
    <content type="html"><![CDATA[<p>sudo ls -al /root/.jenkins/workspace/중랑구_스마트시티/iot-api/build/asciidoc/html5/admin</p><p>sudo ls -al /root/.jenkins/workspace/중랑구_스마트시티/iot-api/build/libs/</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;sudo ls -al /root/.jenkins/workspace/중랑구_스마트시티/iot-api/build/asciidoc/html5/admin&lt;/p&gt;
&lt;p&gt;sudo ls -al /root/.jenkins/workspace/중랑구_스마트시티/i
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JWT_authenticate_process</title>
    <link href="https://gurioh.github.io/guriOH.github.io/JWT_authenticate_process/"/>
    <id>https://gurioh.github.io/guriOH.github.io/JWT_authenticate_process/</id>
    <published>2019-12-16T04:33:21.743Z</published>
    <updated>2019-12-16T06:02:46.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-security">Spring Security</h1><h3 id="필요개념">필요개념</h3><ul><li>접근주체(Principal) : 접근 사용자</li><li>인증(Authenticate) : 접근 주체 확인</li><li>인가(Authorize) : 접근 주체의 권한 검사</li></ul><img src="/Users/hoonoh/Desktop/Summary_arc.jpg" alt="Summary_arc" style="zoom:50%;"/><p>스프링의 구조는 필터와 필터된 Authentication객체를 가지고 실질적인 Validation을 하는 Provider로 나뉜다.</p><h3 id="filter-chain">Filter chain</h3><p>스프링 시큐리티 역시 Filter가 구성이 되어있다.</p><p>기본적으로 11개의 Filter로 구성이 되어있고, Filter를 커스터마이징 하여 추가 확장 시킬수 있다.</p><p>이때 중요한것은 필터간의 순서가 중요하다.</p><h3 id="provider">Provider</h3><p>프로바이더는 실질적인 검증을 하는 클래스로 AuthenticationProvider를 구현하고</p><p>AuthenticationManagerBuilder에 커스터마이징하여 등록이 가능하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  auth.authenticationProvider(authenticationProvider);</span><br><span class="line">  auth.authenticationProvider(jwtAutenticationTokenProvider);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;spring-security&quot;&gt;Spring Security&lt;/h1&gt;
&lt;h3 id=&quot;필요개념&quot;&gt;필요개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;접근주체(Principal) : 접근 사용자&lt;/li&gt;
&lt;li&gt;인증(Authenticate) : 접근 주체 확인
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GCP_SEMINAR</title>
    <link href="https://gurioh.github.io/guriOH.github.io/GCP_SEMINAR/"/>
    <id>https://gurioh.github.io/guriOH.github.io/GCP_SEMINAR/</id>
    <published>2019-12-12T02:14:33.295Z</published>
    <updated>2019-12-12T09:39:54.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="google-cloud-seminar">Google Cloud seminar</h1><p>Google vs AWS</p><ul><li>가격모델<ul><li>더 합리적인듯 (할인(?))</li><li>자체 머신러닝으로 사용 리소스 분석 -&gt; 합리적인 스팩 추천</li></ul></li><li>커스텀 머신 타입<ul><li>GPU 등등</li></ul></li><li>네트워크<ul><li>A사의 경우 전통적인 모델 Each Region vpn set</li><li>하나의 VPC로 관리 -&gt; 모든 리전 접근 가능</li></ul></li></ul><h2 id="데이터베이스">데이터베이스</h2><ul><li>Nosql , cansandra</li></ul><p>bigtable  : 분산저장처리 시작된 이유 -&gt; 논문 한번 보자.</p><h2 id="보안">보안</h2><ul><li>Forrester</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;google-cloud-seminar&quot;&gt;Google Cloud seminar&lt;/h1&gt;
&lt;p&gt;Google vs AWS&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가격모델
&lt;ul&gt;
&lt;li&gt;더 합리적인듯 (할인(?))&lt;/li&gt;
&lt;li&gt;자체 머신러닝으로 사용 리소
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>tip</title>
    <link href="https://gurioh.github.io/guriOH.github.io/tip/"/>
    <id>https://gurioh.github.io/guriOH.github.io/tip/</id>
    <published>2019-12-12T00:12:12.000Z</published>
    <updated>2019-12-12T09:15:08.021Z</updated>
    
    <content type="html"><![CDATA[<p>특정 포트를 사용하는 프로세스 검사</p><ul><li>lsof -i :[port]</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;특정 포트를 사용하는 프로세스 검사&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lsof -i :[port]&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>menu</title>
    <link href="https://gurioh.github.io/guriOH.github.io/menu/"/>
    <id>https://gurioh.github.io/guriOH.github.io/menu/</id>
    <published>2019-12-10T13:23:12.971Z</published>
    <updated>2019-12-17T15:11:07.087Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="AWS_Study.md">Home</a></li><li>Toy-project</li><li>IT<ul><li>BigData<ul><li><a href="/git">Kafka</a></li></ul></li></ul></li><li>Test<ul><li><a href="https://github.com/hexojs/hexo-theme-unit-test" target="_blank" rel="noopener">hexo-unit-test</a><ul><li><a href="/hexo-theme-book-demo/test/hexo-unit-test/categories">Categories</a></li><li><a href="/hexo-theme-book-demo/test/hexo-unit-test/elements">Elements</a></li><li><a href="/hexo-theme-book-demo/test/hexo-unit-test/excerpts">Excerpts</a></li><li><a href="/hexo-theme-book-demo/test/hexo-unit-test/gallery-post">Gallery Post</a></li><li><a href="/hexo-theme-book-demo/test/hexo-unit-test/hello-world">Hello World</a></li><li><a href="/hexo-theme-book-demo/test/hexo-unit-test/images">Images</a></li><li><a href="/hexo-theme-book-demo/test/hexo-unit-test/link-post-without-title">Untitled</a></li><li><a href="/hexo-theme-book-demo/test/hexo-unit-test/link-post">Link Post</a></li><li><a href="/hexo-theme-book-demo/test/hexo-unit-test/long-title">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam justo turpis, tincidunt ac convallis id.</a></li><li><a href="/hexo-theme-book-demo/test/hexo-unit-test/no-title">Untitled</a></li><li><a href="/hexo-theme-book-demo/test/hexo-unit-test/tag-plugins">Tag Plugins</a></li><li><a href="/hexo-theme-book-demo/test/hexo-unit-test/tags">Tags</a></li><li><a href="/hexo-theme-book-demo/test/hexo-unit-test/videos">Videos</a></li><li><a href="/hexo-theme-book-demo/test/hexo-unit-test/%E4%B8%AD%E6%96%87%E6%B8%AC%E8%A9%A6">中文測試</a></li><li><a href="/hexo-theme-book-demo/test/hexo-unit-test/%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%83%86%E3%82%B9%E3%83%88">日本語テスト</a></li></ul></li><li><a href="/hexo-theme-book-demo/test/list-test">list test</a></li></ul></li><li>Demo<ul><li><a href="/hexo-theme-book-demo/demo/markdown-it-demo">markdown-it demo</a></li><li><a href="/hexo-theme-book-demo/demo/katex-demo">katex demo</a></li><li><a href="/hexo-theme-book-demo/demo/footnotes-demo">footnotes demo</a></li><li><a href="/hexo-theme-book-demo/demo/tc-demo">繁體中文測試</a></li><li><a href="/hexo-theme-book-demo/demo/sc-demo">简体中文测试</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;AWS_Study.md&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Toy-project&lt;/li&gt;
&lt;li&gt;IT
&lt;ul&gt;
&lt;li&gt;BigData
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/git&quot;&gt;Kafka&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>sql_20191208</title>
    <link href="https://gurioh.github.io/guriOH.github.io/sql-20191208/"/>
    <id>https://gurioh.github.io/guriOH.github.io/sql-20191208/</id>
    <published>2019-12-09T08:13:29.000Z</published>
    <updated>2019-12-09T08:28:32.830Z</updated>
    
    <content type="html"><![CDATA[<p>AUTO_INCREMENT 초기화</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &apos;테이블이름&apos; AUTO_INCREMENT = 1;</span><br></pre></td></tr></table></figure><p>캐리지 리턴 제거 (개행제거)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE &apos;테이블이름&apos; SET &apos;컬럼명&apos; = replace(&apos;컬럼명&apos;, char(13), &apos;&apos;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AUTO_INCREMENT 초기화&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>sql_20191208</title>
    <link href="https://gurioh.github.io/guriOH.github.io/sql_tunning/"/>
    <id>https://gurioh.github.io/guriOH.github.io/sql_tunning/</id>
    <published>2019-12-09T08:13:29.000Z</published>
    <updated>2019-12-10T09:38:33.717Z</updated>
    
    <content type="html"><![CDATA[<p>SQL 튜닝</p><p>튜닝 기초</p><ul><li>성능 높일시 비중이 높은부분을 높이는것이 중요</li></ul><h1 id="explain-사용">EXPLAIN 사용</h1><ul><li>EXPLAIN을 사용하여 쿼리 플랜 분석<br>![스크린샷 2019-12-05 오전 11.13.11](‎⁨Macintosh HD⁩ ▸ ⁨사용자⁩ ▸ ⁨hoonoh⁩ ▸ ⁨데스크탑⁩/스크린샷 2019-12-05 오전 11.13.11.png)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SQL 튜닝&lt;/p&gt;
&lt;p&gt;튜닝 기초&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;성능 높일시 비중이 높은부분을 높이는것이 중요&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;explain-사용&quot;&gt;EXPLAIN 사용&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;EXPLAIN을 사용하여 쿼리 플랜 분석
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="https://gurioh.github.io/guriOH.github.io/test/"/>
    <id>https://gurioh.github.io/guriOH.github.io/test/</id>
    <published>2019-12-08T13:33:15.000Z</published>
    <updated>2019-12-08T13:33:15.267Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Spring_20191205</title>
    <link href="https://gurioh.github.io/guriOH.github.io/Spring-20191205/"/>
    <id>https://gurioh.github.io/guriOH.github.io/Spring-20191205/</id>
    <published>2019-12-06T01:05:25.000Z</published>
    <updated>2019-12-06T04:57:36.191Z</updated>
    
    <content type="html"><![CDATA[<p>스프링 제어<br>WebMvcConfigurer</p><ul><li>포멧, 메시지 컨버트 관련하여 스프링 MVC를 제어 한다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;스프링 제어&lt;br&gt;
WebMvcConfigurer&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;포멧, 메시지 컨버트 관련하여 스프링 MVC를 제어 한다.&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>git</title>
    <link href="https://gurioh.github.io/guriOH.github.io/git/"/>
    <id>https://gurioh.github.io/guriOH.github.io/git/</id>
    <published>2019-12-05T12:55:49.000Z</published>
    <updated>2019-12-06T00:11:23.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git-ignore-리모트-적용방법">Git ignore 리모트 적용방법</h1><blockquote><p>git rm -r --cached .<br>git add .<br>git commit -m “Apply .gitignore”</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git-ignore-리모트-적용방법&quot;&gt;Git ignore 리모트 적용방법&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;git rm -r --cached .&lt;br&gt;
git add .&lt;br&gt;
git commit -m “Apply .gitignore
      
    
    </summary>
    
    
      <category term="git" scheme="https://gurioh.github.io/guriOH.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://gurioh.github.io/guriOH.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>shellscript</title>
    <link href="https://gurioh.github.io/guriOH.github.io/shellscript/"/>
    <id>https://gurioh.github.io/guriOH.github.io/shellscript/</id>
    <published>2019-12-03T15:26:09.810Z</published>
    <updated>2019-12-04T08:03:34.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="쉘스크립트-문법-정리">쉘스크립트 문법 정리</h1><blockquote><p>쉘스크립트 첫라인 #!/bin/bash 의미?</p><ul><li><p>스크립트파일을 bash로 실행시킨다는 의미</p></li><li><p>기재하지 않으면 리눅스 배포판의 경우 디폴트가 bash이므로 무리 없이 작동하지만<br>다른 쉘간의 오류를 방지를 위함.</p></li></ul></blockquote><h2 id="기본-문법">기본 문법</h2><ul><li><code>echo</code>, <code>printf</code></li><li><code>$#</code> : 스크립트에 전달되는 인자들의 수(C언어에서 argc)</li><li><code>$0</code> : 실행하는 스크립트의 파일명으로 실행했을 때 경로를 포함한다면 경로를 포함해서 나옵니다.</li><li><code>$1</code>, <code>$2</code> … : 스크립트로 전달된 인자들(C언어에서 argv[0], argv[1]…)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"Echo Test"</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"printf Test\n"</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"Name of script : %s\n"</span> <span class="variable">$0</span> </span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%d arguments %s %s\n"</span> <span class="variable">$#</span> <span class="variable">$1</span> <span class="variable">$2</span></span><br></pre></td></tr></table></figure><h2 id="exit">exit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exit 100</span><br><span class="line"></span><br><span class="line"># 스크립트 종료후 echo $? 로 확인.</span><br><span class="line"># 관습적으로 &apos;exit 0&apos;은 성공을 의미합니다.</span><br><span class="line"># 0이 아닌 값은 에러나 예외상황을 나타냅니다.</span><br></pre></td></tr></table></figure><p><code>$?</code>는 스크립트에서 실행시키 명령어의 결과를 확인하는데 특별히 유용</p><h2 id="특수문자">특수문자</h2><p><code>#</code> : 주석</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 주석 뒤에는 명령어가 올수 없다.</span><br><span class="line">\# 이스케이프된 #은 주석을 나타내지 않는다.</span><br></pre></td></tr></table></figure><p><code>;</code> : 명령어 구분자, 두개 이상의 명령어를 한 줄에서 같이 사용할 수 있다.</p><p><code>부분쿼우팅</code>[이중쿼우트]  “content” <strong>문자열</strong> 대부분 특수문자 해석을 막는다.</p><p><code>완전쿼우팅</code>[단일쿼우트]  ‘content’  <strong>문자열</strong>에 들어 있는 모든 특수 문자를 해석하지 못하도록 막아줍니다</p><p><code>명령어치환</code>[백틱(backticks)] ``명령어` 라고 하면 명령어의 결과를 변수값으로 설정할 수있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;쉘스크립트-문법-정리&quot;&gt;쉘스크립트 문법 정리&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;쉘스크립트 첫라인 #!/bin/bash 의미?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스크립트파일을 bash로 실행시킨다는 의미&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>IAM &amp; S3</title>
    <link href="https://gurioh.github.io/guriOH.github.io/AWS_Study/"/>
    <id>https://gurioh.github.io/guriOH.github.io/AWS_Study/</id>
    <published>2019-12-03T10:37:57.000Z</published>
    <updated>2019-12-03T15:56:50.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="s3-transfer-acceleration">S3 Transfer Acceleration</h1><p>Edge 레이어에 유저가 업로드를 하게 되면 벡본 네트워크를 통해 region으로 업로드 전송된다.</p><p>것을 설명함</p><h1 id="cloudfront">CloudFront</h1><p>CloudFront 는 CDN이다.</p><p>Content delibery network</p><p>용어 설명</p><p>Edge location</p><p>Origin</p><p>Distribution</p><h1 id="snowball-it-s-fun">Snowball ( It’s fun)</h1><p>Snowball is petabyte-scale data transport solution</p><h1 id="snowmobile">Snowmobile</h1><p>Snowmobile is an Exabyte-scale data transfer service</p><h1 id="storage-gateway-popular-topic">Storage Gateway(Popular topic)</h1><p>Type</p><p>File gateway (NFS &amp; SMB)</p><p>Volume gateway (iSCSI)</p><ul><li>Stored Volumnes</li><li>Cached Volumnes</li></ul><p>Volume gateway - Tape gateway</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;s3-transfer-acceleration&quot;&gt;S3 Transfer Acceleration&lt;/h1&gt;
&lt;p&gt;Edge 레이어에 유저가 업로드를 하게 되면 벡본 네트워크를 통해 region으로 업로드 전송된다.&lt;/p&gt;
&lt;p&gt;것을 설명함&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="aws" scheme="https://gurioh.github.io/guriOH.github.io/categories/aws/"/>
    
    
      <category term="IAM" scheme="https://gurioh.github.io/guriOH.github.io/tags/IAM/"/>
    
      <category term="S3" scheme="https://gurioh.github.io/guriOH.github.io/tags/S3/"/>
    
      <category term="AWS" scheme="https://gurioh.github.io/guriOH.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>EC2</title>
    <link href="https://gurioh.github.io/guriOH.github.io/AWS_Study_2/"/>
    <id>https://gurioh.github.io/guriOH.github.io/AWS_Study_2/</id>
    <published>2019-12-03T10:37:57.000Z</published>
    <updated>2019-12-04T15:48:40.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ec2-101">EC2 101</h1><p>Amazon Elastic Compute Cloud (EC2)</p><p>= a Web service that provide resizable compute capacity in the cloud</p><ul><li>새로운 서버를 생성하는데 들어가는 비용 감소</li><li>on demand</li><li>reserved</li><li>Spot</li><li>dedicated hosts<br>*Test</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ec2-101&quot;&gt;EC2 101&lt;/h1&gt;
&lt;p&gt;Amazon Elastic Compute Cloud (EC2)&lt;/p&gt;
&lt;p&gt;= a Web service that provide resizable compute capacity in the cl
      
    
    </summary>
    
    
      <category term="aws" scheme="https://gurioh.github.io/guriOH.github.io/categories/aws/"/>
    
    
      <category term="AWS" scheme="https://gurioh.github.io/guriOH.github.io/tags/AWS/"/>
    
      <category term="EC2" scheme="https://gurioh.github.io/guriOH.github.io/tags/EC2/"/>
    
  </entry>
  
  <entry>
    <title>RestfulController</title>
    <link href="https://gurioh.github.io/guriOH.github.io/RestfulController/"/>
    <id>https://gurioh.github.io/guriOH.github.io/RestfulController/</id>
    <published>2019-12-03T04:32:19.000Z</published>
    <updated>2019-12-04T00:25:47.620Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>스프링 시큐리티 이해하기</title>
    <link href="https://gurioh.github.io/guriOH.github.io/SpringSecurity_#1/"/>
    <id>https://gurioh.github.io/guriOH.github.io/SpringSecurity_#1/</id>
    <published>2019-12-03T04:32:19.000Z</published>
    <updated>2019-12-05T05:39:44.717Z</updated>
    
    <content type="html"><![CDATA[<p>![스크린샷 2019-12-05 오전 11.13.11](/Users/hoonoh/Desktop/스크린샷 2019-12-05 오전 11.13.11.png)</p><p>스프링시큐리티 시나리오</p><ul><li>인증</li><li>권한체크</li></ul><h4 id="authentication-객체">Authentication 객체</h4><ul><li>이름</li><li>권한</li><li>인증여부</li></ul><p>AuthenticatioFilter 에서 사용자 정보를 꺼내 Authentication 객체를 만들고,</p><p>AuthenticationProvider에 전달한다.</p><p>AuthenticationProvider에서는 실제 인증이 이루어 지고, 인증 결과를 Authentication에 담아 SecurityContextHolder에 저장 성공 여부에 따라 handler를 실행한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;![스크린샷 2019-12-05 오전 11.13.11](/Users/hoonoh/Desktop/스크린샷 2019-12-05 오전 11.13.11.png)&lt;/p&gt;
&lt;p&gt;스프링시큐리티 시나리오&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>hexo command</title>
    <link href="https://gurioh.github.io/guriOH.github.io/hexo-command/"/>
    <id>https://gurioh.github.io/guriOH.github.io/hexo-command/</id>
    <published>2019-12-02T00:21:02.000Z</published>
    <updated>2019-12-02T00:22:54.900Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>layout : 기본 레이아웃은 3가지 종류가 있고 각기 다른 경로에 보관됩니다.</p><ul><li>post(Default)</li><li>page</li><li>draft<br>title : 파일 제목</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
    
      <category term="hexo-command" scheme="https://gurioh.github.io/guriOH.github.io/tags/hexo-command/"/>
    
  </entry>
  
  <entry>
    <title>카프카(Kafka) 실행시키기 - 스크립트</title>
    <link href="https://gurioh.github.io/guriOH.github.io/How_to_build_kafka_source_intellij/"/>
    <id>https://gurioh.github.io/guriOH.github.io/How_to_build_kafka_source_intellij/</id>
    <published>2019-12-01T08:46:57.000Z</published>
    <updated>2019-12-01T11:06:59.449Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/kafka/1.jpeg" alt=""></p><p>이제 카프카를 실행 시켜 보자!!</p><p>목표는 아래와 같다.</p><ol><li>카프카를 설치해서 빌드된 스크립트를 이용하여 카프카의 동작여부를 확인해보자.</li><li>최종적으로는 Intellij를 통해 빌드해보며 어떤 식으로 돌아가는지 코드로 확인해 보자.</li></ol><h1 id="카프카-kafka-실행시키기-스크립트">카프카(Kafka) 실행시키기 - 스크립트</h1><h1 id="step-1-download">Step.1 DownLoad</h1><p>카프카 공식 홈페이지에서 다운로드!!</p><p>현재기준 kafka 최신 버전은 2.3.0이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zvxf kafka_2.12-2.3.0.tgz </span><br><span class="line">$ cd kafka_2.12-2.3.0.tgz</span><br></pre></td></tr></table></figure><p>다운로드 받아서 압축을 푹어준다.</p><h1 id="step-2-실행시키기">Step.2 실행시키기</h1><p>카프카를 실행 시켜주면 된다.</p><p>먼저 카프카는 기본적으로 Zookeeper에서 관리가 되고 있기 때문에 Zookeeper가 실행이 되어야만 동작한다.</p><p>따라서 Kafka실행전 Zookeeper를 실행해야 한다.</p><p>먼저 두 어플리케이션을 실행시키기 전에 설정파일을 일부 수정한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zookeeper.properties</span><br><span class="line"></span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line">dataDir=/tmp/zookeeper</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=2181</span><br><span class="line"># disable the per-ip limit on the number of connections since this is a non-production config</span><br><span class="line">maxClientCnxns=0</span><br><span class="line"></span><br><span class="line">server.1 = 127.0.0.1&quot;2888:3888 //.[number] 는 아이디 값.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server.properties</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">############################# Server Basics #############################</span><br><span class="line"></span><br><span class="line"># The id of the broker. This must be set to a unique integer for each broker.</span><br><span class="line">broker.id=1</span><br><span class="line"></span><br><span class="line">############################# Socket Server Settings #############################</span><br><span class="line">listeners=PLAINTEXT://:9092</span><br><span class="line">advertised.listeners=PLAINTEXT://127.0.0.1:9092</span><br><span class="line"></span><br><span class="line">############################# Zookeeper #############################</span><br><span class="line"></span><br><span class="line"># Zookeeper connection string (see zookeeper docs for details).</span><br><span class="line"># This is a comma separated host:port pairs, each corresponding to a zk</span><br><span class="line"># server. e.g. &quot;127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002&quot;.</span><br><span class="line"># You can also append an optional chroot string to the urls to specify the</span><br><span class="line"># root directory for all kafka znodes.</span><br><span class="line">zookeeper.connect=127.0.0.1:2181</span><br><span class="line"></span><br><span class="line"># Timeout in ms for connecting to zookeeper</span><br><span class="line">zookeeper.connection.timeout.ms=6000</span><br></pre></td></tr></table></figure><p>위 와 같이 zookeeper에 서버정보를 추가하고 (복수개 설정가능)</p><p>Kafka의 server 프로퍼티에도 해당 zookeeper의 정보를 입력해주면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ zookeeper-server-start.sh config/zookeeper.properties</span><br><span class="line">$ kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure><p>그리고 두 어플리케이션을 실행한다.</p><p>이제 Topic을 생성 후 Producer 인풋 메시지를 저장하고 Consumer로 받아보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics.sh --create --zookeeper 127.0.0.1:2181 --replication-factor 1 --partitions 1 --topic test</span><br><span class="line"></span><br><span class="line">Created topic test.</span><br></pre></td></tr></table></figure><p>다운받은 소스에서 토픽을 생성하는 스크립트를 이용하여 Test 라는 토픽을 생성하였다.</p><blockquote><p>Topic은 추가로 생성, 삭제가 가능하다</p></blockquote><p>이제 Topic과 마찬가지로 생산자와 소비자 스크립트를 이용해서 메시지를 교환하여 보자</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-producer.sh --ber-list 127.0.0.1:9092 --topic test</span><br><span class="line">&gt;Test</span><br><span class="line">&gt;Hi</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>위와 같이 생산자가 메시지를 입력한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-consumer.sh --bootstrap-server 127.0.0.1:9092 --topic test --from-beginning</span><br><span class="line">Test</span><br><span class="line">Hi</span><br></pre></td></tr></table></figure><p>–from-beginning 은 처음부터 메시지를 읽겠다는 뜻이고 입력한 메시지를 읽어온것을 확인 할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/kafka/1.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;이제 카프카를 실행 시켜 보자!!&lt;/p&gt;
&lt;p&gt;목표는 아래와 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;카프카를 설치해서 빌드된 스크립트를 이용하여 카프카의 동작여부를 확인해보
      
    
    </summary>
    
    
      <category term="BigData" scheme="https://gurioh.github.io/guriOH.github.io/categories/BigData/"/>
    
    
      <category term="Kafka" scheme="https://gurioh.github.io/guriOH.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>카프카(Kafka) 실행시키기 - Intellj</title>
    <link href="https://gurioh.github.io/guriOH.github.io/How_to_build_kafka_with_intellij/"/>
    <id>https://gurioh.github.io/guriOH.github.io/How_to_build_kafka_with_intellij/</id>
    <published>2019-12-01T08:46:57.000Z</published>
    <updated>2019-12-02T10:05:27.898Z</updated>
    
    <content type="html"><![CDATA[<p>앞선 내용에서 Kafka에서 제공하는 스크립트를 통해 카프카를 실행 시켜 보았다.</p><p>오늘은 카프카를 IDE를 통하여 실행을 시킴으로서 Kafka가 내부적으로 어떻게 동작을 하는지 더 정확히 확인을 해보려고 한다</p><p>오늘의 목표</p><ul><li>Intellij를 이용하여 Kafka 빌드</li></ul><p>우선 Kafka 빌드에 앞서 선행적으로 준비가 되어야 할 것이 있다.</p><ul><li>git</li><li>Java 8</li><li>IntelliJ</li></ul><p>위 환경이 준비가 되었다는 가정하에 문서를 보면 된다.</p><blockquote><p>인텔리제이의 경우 Scala, Gradle을 플러그인 형태로 아주 쉽게 다운로드 받을 수 있다.</p><p>만약 이클립스를 사용한다면 위 두가지를 다운로드 받거나 플러그인이 있다면 추가해서 사용하자.</p><p>카프카는 Scala 로 작성된 어플리케이션 이다.</p></blockquote><h1 id="카프카-kafka-실행시키기-with-intellij">카프카(Kafka)  실행시키기 with Intellij</h1><h2 id="step-1-git-clone">Step-1. Git clone</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/apache/kafka.git</span><br></pre></td></tr></table></figure><p>위 명령어를 통해 Kafka 소스를 내려 받는다.</p><h2 id="step-2-build">Step-2. Build</h2><p>카프카의 실행에 앞서 실행에 필요한 서드 파티 파일들을 받아야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./gradlew clean</span><br><span class="line">./gradlew jar</span><br></pre></td></tr></table></figure><h2 id="step-3-run-kafka">Step-3. Run Kafka</h2><p><img src="/image/kafka/3.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">VM Options</span><br><span class="line">-Dkafka.logs.dir=/tmp/kafka -Dlog4j.configuration=file:config/log4j.properties</span><br><span class="line"></span><br><span class="line">Program arguments</span><br><span class="line">config/server.properties</span><br></pre></td></tr></table></figure><p>VM Options은 server.properties 에 설정해둔 로그파일 저장 위치와 log4j 설정 정보를 입력한다.</p><h2 id="error-1">Error-#1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span><br><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticMDCBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation MDCAdapter implementation.</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html#no_static_mdc_binder for further details.</span><br></pre></td></tr></table></figure><p>실행했을때 위와 같은 에러로그가 발생한다면</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">kafka/build.gradle</span><br><span class="line">project(&apos;:core&apos;) &#123;</span><br><span class="line">  dependencies &#123;</span><br><span class="line">     compile project(&apos;:clients&apos;)</span><br><span class="line">     compile libs.slf4jlog4j12</span><br><span class="line">     ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">kafka/gradle/dependencies.gradle</span><br><span class="line">versions += [</span><br><span class="line">   ....</span><br><span class="line">   zstd: &quot;1.4.3-1&quot;,</span><br><span class="line">   slf4jlog4j12: &quot;2.0.0-alpha1&quot;</span><br><span class="line">]</span><br><span class="line">libs += [</span><br><span class="line">  .....</span><br><span class="line">  httpclient:     &quot;org.apache.httpcomponents:httpclient:$versions.httpclient&quot;,</span><br><span class="line">slf4jlog4j12: &quot;org.slf4j:slf4j-log4j12:$versions.slf4jlog4j12&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>위와 같이 'slf4jlog4j12’를 추가.</p><p>Ref. <a href="https://medium.com/@chandreshpancholi007/how-to-setup-apache-kafka-source-code-on-intellij-b204966d7c2" target="_blank" rel="noopener">https://medium.com/@chandreshpancholi007/how-to-setup-apache-kafka-source-code-on-intellij-b204966d7c2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;앞선 내용에서 Kafka에서 제공하는 스크립트를 통해 카프카를 실행 시켜 보았다.&lt;/p&gt;
&lt;p&gt;오늘은 카프카를 IDE를 통하여 실행을 시킴으로서 Kafka가 내부적으로 어떻게 동작을 하는지 더 정확히 확인을 해보려고 한다&lt;/p&gt;
&lt;p&gt;오늘의 목표
      
    
    </summary>
    
    
      <category term="BigData" scheme="https://gurioh.github.io/guriOH.github.io/categories/BigData/"/>
    
    
      <category term="Kafka" scheme="https://gurioh.github.io/guriOH.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>카프카(Kafka) 이해하기</title>
    <link href="https://gurioh.github.io/guriOH.github.io/What%20is%20kafka/"/>
    <id>https://gurioh.github.io/guriOH.github.io/What is kafka/</id>
    <published>2019-12-01T08:46:57.000Z</published>
    <updated>2019-12-01T11:11:48.131Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/kafka/1.jpeg" alt=""></p><h1 id="카프카-kafka-이해하기">카프카(Kafka) 이해하기</h1><p>오늘은 카프카에 대해서 간략하게 알아보며 간단하게 실행을 시켜보는 시간을 가져보자.</p><p>그냥 궁금해서… :)</p><p>​Let’s get it!</p><h1 id="메시징-서비스">메시징 서비스</h1><p>먼저 카프카는 메시지 퍼블리싱 어플리케이션으로서 메시지를 서로 전달할 수 있도록 연결하는 오픈소스입니다.</p><p>카프카는 특히 실시간 대량 정보를 다루는데에 유용하게 사용될 수 있는데, 여러 정보를 소비자에게 빠르게 전달하는 과정에서 생기는 문제점을 해결하기 위한 솔루션입니다.</p><blockquote><p>카프카는 활동 스트림 데이터를 처리하는 데 유용하다는 점에서 스크라이브 또는 플럼 과 유사해 보이지만 아키텍처 관점에서는 액티브엠큐, 래빗엠큐 같은 메시징 시스템에 더 가깝다.</p></blockquote><h1 id="카프카-특징">카프카 특징</h1><p>카프가는 아래와 같은 특징을 가집니다.</p><ul><li>비휘발성메시징 : 빅데이터로 부터 실제 가치를 끌어내기 위해선 어떠한 정보유실도 있어선 안되는데, 카프카는 O(1)의 디스크 구조로 디자인 되어서 많은 데이터의 저장 메시지라도 상수 시간의 성능을 제공</li><li>높은 처리량 : 초당 수백건 (정확하지 않음)</li><li>분산 : 카프카 서버들을 대상으로 메시지 파티셔닝을 지원. 또한 소비자 장비들이 속한 클러스터 단위 분산 소비를 지원하는데 파티션 단위로만 순서를 가짐</li><li>다양한 클라이언트 지원 : 자바, 루비, 닷넷, PHP등등</li><li>실시간</li></ul><h1 id="카프카-목적">카프카 목적</h1><p>카프카의 목적은 하둡시스템으로의 병렬 로드와 클러스터의 장비들에 의한 실시간 분할 소비를 지원해서 오프라인</p><p>과 온라인 처리를 통합하는것을 목적으로 합니다.</p><h1 id="카프카-사용-예">카프카 사용 예</h1><ul><li>링크드인, 데이터시프트, 트위터 , 포스퀘어, 스퀘어</li></ul><h1 id="카프카-메시징-처리-과정">카프카 메시징 처리 과정</h1><p>카프카 디자인의 핵심</p><ol><li>생산자는 카프카 브로커에 생성된 카프카 토픽으로 메시지를 보낸다.</li><li>카프카 브로커는 카프카 서버로 동작</li><li>소비자는 메시지를 얻기 위해 카프카 토픽을 구독한다.</li></ol><h1 id="카프카-주요-설계-요소">카프카 주요 설계 요소</h1><ol><li>카프카의 핵심은 메시지를 파일 시스템에 저장하고 캐싱하는 것이다. 데이터는 즉시 OS커널 페이지에 쓴다.<br>데이터를 디스크에 캐시하고 플러시하는 것은 설정할 수 있다.</li><li>카프카는 필요에 따라 메시지 소비후 다시 메시지를 소비 할 수 있게 메시지의 장기 보관을 지원</li><li>카프카는 네트워크 부하를 줄이기 위해 메시지를 그룹으로 묶는 메시지 집합을 사용</li><li>메시지 소비에 대한 메타정보가 서버에 저장되는 대부분의 메시지 시스템과 다르게 카프카는 소비자 레벨에서 소비된 메시지의 상태를 가지고 있다.<ul><li>실패에 따른 메시지 유실 해결</li><li>단일 메시지의 복수 전달</li></ul></li><li>소비자는 상태를 주키퍼에 저장(기본설정), 온라인 트랜잭션 처리 애플리케이션으로 사용가능</li><li>카프카는 생산자 소비자 Push and Pull 모델 방식.</li><li>카프카에서 마스터 개념은 없고 모든 브로커를 피어로 다룸으로, 브로커의 메타 데이터는 주키퍼에 보관하고 생산자 소비자에 공유하므로, 브로커의 추가,제거가 쉽다.</li><li>생산자는 메시지를 브로커에 보내는데 , 비동기, 동기 모드를 선택할 수 있다.</li></ol><h1 id="카프카-메시지-압축">카프카 메시지 압축</h1><ul><li>Gzip, Snappy 지원</li><li>네트워크단의 부하를 줄이기 위해 압축지원, 소비자단은 부하가 증가.</li></ul><h1 id="카프카의-클러스터-미러링">카프카의 클러스터 미러링</h1><p>카프카 미러링 기능은 기존 클러스터의 복사본을 만드는데 사용한다.</p><p>ex &gt; 활성 데이터 센터로부터 비활성 데이터 센터로 복제하는 경우</p><p><strong>카프카에서 원본 클러스터로부터 대상 클러스터로 미러링을 만드는 도구를 제공</strong> ( 살펴보장!)</p><h1 id="카프카-리플리케이션-이해-필요">카프카 리플리케이션(이해 필요)</h1><p>메시지 파티셔닝</p><p>어떻게 파티션될 것인지 메시지 생산자에 의해 결정, 브로커는 메시지가 들어온 순서대로 저장.</p><p>파티션의 개수는 브로커 내의 각 토픽에 설정할 수 있다.</p><h1 id="kafka-생산자">Kafka 생산자</h1><p>생산자 어플리케이션은 메시지를 만들고 나중의 소비를 위해 카프카 브로커에 배포한다.</p><p>생산자는 다양한 성격일 수 있다.</p><ul><li>애플리케이션 프론트엔드</li><li>서비스의 백엔드</li><li>프록시 애플리케이션</li><li>하둡 생산자</li><li>etc</li></ul><h1 id="메시지-생산자를-위한-카프카-api">메시지 생산자를 위한 카프카 API</h1><h3 id="자바-생산자-api">자바 생산자 API</h3><p>카프카는 단일 또는 다중 토픽에 메시지들을 생성하는 Producer&lt;K,V&gt; 클래스를 제공</p><p>파티션은 선택사항이다.</p><p>생산자는 스칼로 작성된 자바의 제네릭 타입이기 때문에 매개변수의 타입을 기술해야함.</p><h1 id="kafka-소비자">Kafka 소비자</h1><p>소비자 어플리케이션은 메시지들을 소비하고 메시지들로부터 데이터를 추출하는 어플리케이션이다.</p><p>소비자 역시 다양한 성격일 수 있다.</p><ul><li>실시간 분석 어플리케이션</li><li>NoSQL관련 어플리케이션</li><li>데이터 웨어하우스 솔루션</li><li>백엔드 서비스</li><li>하둡 소비자</li><li>구독 서비스</li><li>etc</li></ul><h1 id="메시지-소비자를-위한-카프카-api">메시지 소비자를 위한 카프카 API</h1><p>카프카는 자바 기반 Consumer로 두가지 타입의 API를 제공</p><ul><li>상위 레벨 소비자</li><li>단순 소비자</li></ul><p>상위 레벨 소비자 API는 소비자 API의 하위 레벨의 구현을 추상화해 제공</p><p>반변 단순 소비자 API는 기본 하위 레벨의 구현을 오버라이드할 수 있어 더 많은 제어를 할 수 있다.</p><h3 id="상위-레벨-소비자-api">상위 레벨 소비자 API</h3><p>상위 레벨의 소비자 API는 메시지 오프셋을 다룰 필요 없이 데이터를 쓸 때 사용</p><p>메시지 소비시 일어나는 대부분 하위 레벨의 기능을 추상화하였다.</p><p>특징으로는 주키퍼의 특정 영역에 최근 읽은 오프셋을 저장하고 오프셋은 프로세스가 시작할 때 카프카에 제공된 소비자 그룹 이름에 기반을 둬서 저장한다.</p><h3 id="소비자-그룹">소비자 그룹</h3><p>소비자 그룹의 이름은 클러스터에서 유일하고 전역적이다.</p><p>이미 사용중인 소비자 그룹 이름을 가진 새로운 소비자는 시스템에 예기치 못한 행동을 발생 시킬 수 있다.</p><p>새로운 프로세스가 기존 소비자 그룹 이름을 가지고 시작하면 스레드 간 리발란스를 작동시키는데</p><p>리발란스 후 새로운 프로세스로 가야하는 몇몇 메시지들이 이전 프로세스로 갈 수 있고 오작동을 초래할 수도 있다</p><p>(현재 버전 2.13 에서는 확인해봐야 할 것 같다.)</p><p>해결방법은 기존 소비자 그룹의 이름을 가지는 새로운 소비자를 시작 하려면 기존의 모든 소비자를 중단…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/kafka/1.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;카프카-kafka-이해하기&quot;&gt;카프카(Kafka) 이해하기&lt;/h1&gt;
&lt;p&gt;오늘은 카프카에 대해서 간략하게 알아보며 간단하게 실행을 시켜보는 시간을 가져보자.
      
    
    </summary>
    
    
      <category term="BigData" scheme="https://gurioh.github.io/guriOH.github.io/categories/BigData/"/>
    
      <category term="Middleware" scheme="https://gurioh.github.io/guriOH.github.io/categories/Middleware/"/>
    
    
      <category term="Kafka" scheme="https://gurioh.github.io/guriOH.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Spring_CRUD_practice</title>
    <link href="https://gurioh.github.io/guriOH.github.io/AddressBook/"/>
    <id>https://gurioh.github.io/guriOH.github.io/AddressBook/</id>
    <published>2019-11-01T10:37:57.000Z</published>
    <updated>2019-12-02T10:05:27.899Z</updated>
    
    <content type="html"><![CDATA[<p>Autor : 오 훈</p><p>Title : AddressBook</p><h1 id="addressbook-github-link">AddressBook (<a href="https://github.com/guriOH/AddressBook.git" target="_blank" rel="noopener">GitHub Link</a>)</h1><h2 id="1-목적">1. 목적</h2><ul><li>GET, PUT, POST, DELETE 를 이용한  주소록  CRUD 구현</li></ul><h2 id="2-어플리케이션-디자인">2. 어플리케이션 디자인</h2><h3 id="none"><img src="/image/addressInfo/1.png" alt=""></h3><p>구현에 앞서 기본적인 어플리케이션 디자인을 설명 드리겠습니다.</p><p>어플리케이션은 크게 데이터 클래스 (Request, Response, Model), 비즈니스 로직을 포함한 데이터 처리 클래스로 나뉩니다.</p><h2 id="3-프로젝트-구성">3. 프로젝트 구성</h2><h2 id="none-v2"><img src="/image/addressInfo/2.png" alt=""></h2><p>프로젝트는  SpringBoot 어플리케이션을 사용하여 작성하였습니다.</p><p>Repository 컨트롤로는 JPA api를 사용하였고,  DataBase로는  인메모리디비 H2를 사용하였습니다.</p><h3 id="3-1-데이터-구성">3.1 데이터 구성</h3><p>AddressInfo.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Getter</span> <span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddressInfo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(strategy= GenerationType.SEQUENCE)</span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String phonenumber;</span><br><span class="line"><span class="keyword">private</span> String address;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AddressInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AddressInfo</span><span class="params">(String name, String phonenumber, String address, String email)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.phonenumber = phonenumber;</span><br><span class="line"><span class="keyword">this</span>.address = address;</span><br><span class="line"><span class="keyword">this</span>.email = email;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AddressInfo 클래스는 데이터 테이블에 저장될 데이터의 모델로서 Key값은 Integer형태의 Id를 Auto 생성합니다.<br>그리고 주소록에 들어갈 내용으로는 이름, 연락처, 주소, 이메일이 있습니다.</p><p>Getter, Setter 어노테이션을 사용하도록  org.projectlombok.lombok 라이브러리를 사용하였습니다.</p><h2 id="4-상세-설명">4. 상세 설명</h2><h3 id="4-1-get">4.1 GET</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/address"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddressController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AddressServiceImpl addressService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/&#123;id&#125;"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">AddressResponse <span class="title">getAddress</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span><span class="keyword">final</span> Integer id) </span>&#123;</span><br><span class="line">List&lt;String&gt; errors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">AddressInfo toDoItem = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">toDoItem = addressService.findById(id);</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">errors.add(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> AddressAdapter.addressInfoResponse(toDoItem, errors, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@RequestMapping</span>(method = RequestMethod.GET)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">List&lt;AddressResponse&gt; <span class="title">getAllMember</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; errors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;AddressInfo&gt; toDoItems = addressService.findAllMembers(); </span><br><span class="line">List&lt;AddressResponse&gt; toDoItemResponses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">toDoItems.stream().forEach(toDoItem -&gt; &#123;</span><br><span class="line">toDoItemResponses.add(AddressAdapter.addressInfoResponse(toDoItem, errors, <span class="keyword">null</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> toDoItemResponses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AddressController는 어노테이션을 이용하여 이 클래스가 RESTFul API임을 명시합니다.</p><p>그리고 @RequestMapping을 사용하여 해당 컨트롤러의 최상위 URL을 정의 합니다.</p><p>@RequestMapping(value = “/{id}”, method = RequestMethod.GET)</p><ul><li><p>AddressResponse getAddress(@PathVariable(“id”)final Integer id)</p><ol><li><p>getAddress는 GET 방식 사용하여 호출합니다. @PathVariable으로 정의되어 있는 값을  URL에서 선택하여 getAddress의 인자 ID로 넣어 줍니다.</p></li><li><p>addressService.findById(id)에서는 내부적으로 repository서비스 구현 클래스를 호출하여 해당  ID(key value)를 가진 데이터를 가져옵니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AddressInfo <span class="title">findById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> addressRepository.findById(id).orElse(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AddressAdapter.addressInfoResponse(toDoItem, errors, null)<br>가져온 결과값을 Adapter에서 Response객체로 변환하여 반환합니다.</p></li></ol></li><li><p>List<AddressResponse> getAllMember()</p><ol><li><p>getAllMember GET 방식 사용하여 호출합니다.</p></li><li><p>addressService.findAllMembers()에서는 addressRepository.findAll()를 호출하여 모든 주소 데이터를 가져옵니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;AddressInfo&gt; <span class="title">findAllMembers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> addressRepository.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AddressAdapter.addressInfoResponse(toDoItem, errors, null) 가져온 결과값을 Adapter에서 Response객체로 변환하여 반환합니다.</p></li></ol></li></ul><h3 id="4-2-post">4.2 POST</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(method = RequestMethod.POST)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">AddressResponse <span class="title">create</span><span class="params">(@RequestBody <span class="keyword">final</span> AddressRequest addressReqeust)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; errors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">AddressInfo addressInfo = AddressAdapter.addressInfo(addressReqeust);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">addressInfo = addressService.saveMember(addressInfo);</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">errors.add(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> AddressAdapter.addressInfoResponse(addressInfo, errors, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@RequestBody를 사용하여 HTTP 요청을 AddressRequest로 받고, AddressAdapter에서는 이  Http요청을 AddressInfo객체로 변환한다.</p><ul><li><p>AddressResponse create(@RequestBody final AddressRequest addressReqeust)</p><ol><li><p>addressService.saveMemver(addressInfo)에서는 addressRepository.save(member)를 호출하여 데이터를 저장한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AddressInfo <span class="title">saveMember</span><span class="params">(AddressInfo member)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> addressRepository.save(member);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><p>@ResponseBody는 create 메소드 결과 객체를 Http 결과를  Json형태로 돌려준다.</p><h3 id="4-3-put">4.3 PUT</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/&#123;id&#125;"</span>, method = RequestMethod.PUT)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">AddressResponse <span class="title">updateAddress</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id,  @RequestBody <span class="keyword">final</span> AddressRequest addressReqeust) </span>&#123;</span><br><span class="line">List&lt;String&gt; errors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">AddressInfo source = AddressAdapter.addressInfo(addressReqeust);</span><br><span class="line">AddressInfo updated = addressService.updateMember(id, source);</span><br><span class="line"><span class="keyword">return</span> AddressAdapter.addressInfoResponse(updated, errors, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PUT을 사용하여 데이터를 수정합니다. 먼저 @PathVariable(“id”)와 같이 URL에서 변환 대상 객체의 Key(Id)와 수정 내용를 전달 받습니다.</p><ul><li><p>AddressAdapter.addressInfo(addressReqeust) 먼저 수정할 내용의 객체를 AddressAdapter에서 Model 객체로 변환합니다.</p></li><li><p>addressService.updateMember(id, source)는 내부적으로 모든 주소록을 가져와 해당 ID값을 가지는  Model을 수정할  Model로 업데이트 합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AddressInfo <span class="title">updateMember</span><span class="params">(Integer id, AddressInfo source)</span> </span>&#123;</span><br><span class="line">AddressInfo target = addressRepository.findById(id).orElse(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span>(target == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">target.setAddress(source.getAddress());</span><br><span class="line">target.setEmail(source.getEmail());</span><br><span class="line">target.setName(source.getName());</span><br><span class="line">target.setPhonenumber(source.getPhonenumber());</span><br><span class="line"></span><br><span class="line">addressRepository.save(target);</span><br><span class="line"><span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>@ResponseBody는 create 메소드 결과 객체를 Http 결과를  Json형태로 돌려준다.</p><h3 id="4-4-delete">4.4 DELETE</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/&#123;id&#125;"</span>, method = RequestMethod.DELETE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">AddressResponse <span class="title">deleteAddress</span><span class="params">(@PathVariable(value=<span class="string">"id"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">List&lt;String&gt; errors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">String info = <span class="string">"Delete fail"</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(addressService.deleteMember(id)) &#123;</span><br><span class="line">info = <span class="string">"Delete success"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">errors.add(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> AddressAdapter.addressInfoResponse(<span class="keyword">null</span>, errors, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DELETE를 사용하여 데이터를 삭제합니다. @PathVariable(“id”)에 명시된 내용을 URL에서 가져옵니다.</p><ul><li><p>addressService.deleteMember(id) 에 삭제할 대상  key값을 주어, 해당 객체를 가져와 delete 합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">deleteMember</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">AddressInfo target = addressRepository.findById(id).orElse(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span>( target == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">addressRepository.delete(target);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-테스트">5. 테스트</h2><ol><li>Postman을 활용한 로직 호출 (DB 로그 확인)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Autor : 오 훈&lt;/p&gt;
&lt;p&gt;Title : AddressBook&lt;/p&gt;
&lt;h1 id=&quot;addressbook-github-link&quot;&gt;AddressBook (&lt;a href=&quot;https://github.com/guriOH/AddressBook.g
      
    
    </summary>
    
    
      <category term="Study" scheme="https://gurioh.github.io/guriOH.github.io/categories/Study/"/>
    
    
      <category term="Spring" scheme="https://gurioh.github.io/guriOH.github.io/tags/Spring/"/>
    
      <category term="H2" scheme="https://gurioh.github.io/guriOH.github.io/tags/H2/"/>
    
      <category term="CRUD" scheme="https://gurioh.github.io/guriOH.github.io/tags/CRUD/"/>
    
  </entry>
  
</feed>
