<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Henry 기술블로그</title>
  
  
  <link href="/guriOH.github.io/atom.xml" rel="self"/>
  
  <link href="https://gurioh.github.io/guriOH.github.io/"/>
  <updated>2020-02-28T15:01:15.670Z</updated>
  <id>https://gurioh.github.io/guriOH.github.io/</id>
  
  <author>
    <name>Henry Oh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>인터넷이란?</title>
    <link href="https://gurioh.github.io/guriOH.github.io/Basic/internet/"/>
    <id>https://gurioh.github.io/guriOH.github.io/Basic/internet/</id>
    <published>2020-02-28T14:56:00.000Z</published>
    <updated>2020-02-28T15:01:15.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="인터넷이란">인터넷이란??</h1><p>흔히 말하는 인터넷이란?</p><p>인터넷이란 단어에서 그 의미를 찾을 수 있다.</p><p>Internet = Inter + net</p><p>Inter는 '상호간의’라는 뜻이고, net은 network을 의미한다.</p><p>즉, 인터넷이란 네트워크간의 상호 연결되어있는 상태를 말한다.</p><p>그렇다면 인터넷은 어떻게 동작할까…</p><h1 id="인터넷의-동작-원리">인터넷의 동작 원리</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;인터넷이란&quot;&gt;인터넷이란??&lt;/h1&gt;
&lt;p&gt;흔히 말하는 인터넷이란?&lt;/p&gt;
&lt;p&gt;인터넷이란 단어에서 그 의미를 찾을 수 있다.&lt;/p&gt;
&lt;p&gt;Internet = Inter + net&lt;/p&gt;
&lt;p&gt;Inter는 &#39;상호간의’라는 뜻이고, net은
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>브라우저?</title>
    <link href="https://gurioh.github.io/guriOH.github.io/Basic/Browser/"/>
    <id>https://gurioh.github.io/guriOH.github.io/Basic/Browser/</id>
    <published>2020-02-28T14:56:00.000Z</published>
    <updated>2020-02-28T15:20:31.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="브라우저">브라우저</h1><p>브라우저 역시 소프트웨어.<br>가장 많이 사용하는 소트웨어.</p><h1 id="주요기능">주요기능</h1><p>사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는것<br>자원은 보통 HTML이지만 PDF, 또는 이미지 등 다른 형태일 수 있다.<br>자원의 주소는 URI에 의해 정해진다.</p><h1 id="구성요소">구성요소</h1><p><img src="../../image/2020-02-29-00-13-25.png" alt=""></p><ol><li>사용자 인터페이스 : 주소표시줄, 이전/다음 버튼 등 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분</li><li>브라우저 엔진 - 사용자 인터페이스와 렌더릴 엔진 사이의 동작 제어</li><li>렌더링 엔진 - 요청한 콘텐츠를 표시.</li><li>통신 - 네트워크 호출에 사용 - 플랫폼 독자적인 인터페이스이고 각 플랫폼 하부에서 실행</li><li>UI 백엔드 - 콤보 박스와 창 같은 기본적인 장치를 그림. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서 OS 사용자 인터페이스 체계를 사용.</li><li>자바스크립트 해석기 - 자바스크립트 코드를 해석하고 실행.</li><li>자료 저장소 - 이 부분은 자료를 저장하는 캡슐. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장할 필요가 있음.</li></ol><ul><li>크롬은 대부분의 브라우저와 달리 각 탭마다 별도의 렌더링 엔진 인스턴스를 유지함, 독립적인 프로세스로 처리.</li></ul><h1 id="렌더링-엔진">렌더링 엔진</h1><p>애플 사파리, 크롬 - 웹킷<br>파이어폭스 - 게코</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;브라우저&quot;&gt;브라우저&lt;/h1&gt;
&lt;p&gt;브라우저 역시 소프트웨어.&lt;br&gt;
가장 많이 사용하는 소트웨어.&lt;/p&gt;
&lt;h1 id=&quot;주요기능&quot;&gt;주요기능&lt;/h1&gt;
&lt;p&gt;사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는것&lt;br&gt;
자원은 보통 H
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>language/Java/Environment</title>
    <link href="https://gurioh.github.io/guriOH.github.io/language/Java/Environment/"/>
    <id>https://gurioh.github.io/guriOH.github.io/language/Java/Environment/</id>
    <published>2020-02-19T00:35:30.706Z</published>
    <updated>2020-02-23T12:29:25.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mac-jdk-설치-및-환경변수-설정">Mac JDK 설치 및 환경변수 설정</h1><p>Default 설치 위치는<br><code>/usr/libexec/java_home -V</code><br>로 확인 가능하다.</p><p><img src="../../../image/2020-02-19-09-37-55.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mac-jdk-설치-및-환경변수-설정&quot;&gt;Mac JDK 설치 및 환경변수 설정&lt;/h1&gt;
&lt;p&gt;Default 설치 위치는&lt;br&gt;
&lt;code&gt;/usr/libexec/java_home -V&lt;/code&gt;&lt;br&gt;
로 확인 가능하다.&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cloud/AWS/Exam/part5</title>
    <link href="https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Exam/part5/"/>
    <id>https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Exam/part5/</id>
    <published>2020-02-14T06:22:45.272Z</published>
    <updated>2020-02-17T14:47:38.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="영역5-운영-면에서-탁월한-아키텍처-정의">영역5 : 운영 면에서 탁월한 아키텍처 정의</h1><h1 id="cloudwatch-이벤트를-사용한-amazon-ec2-자동화">CloudWatch 이벤트를 사용한 Amazon EC2 자동화</h1><ul><li>CloudWatch Events를 사용하여 AWS 서비스를 자동화하고 애플리케이션 가용성 문제나 리소스 변경 같은 시스템 이벤트에 자동으로 응답</li></ul><h2 id="cloudwatch-이벤트에서-자동으로-트리거-할수-있는-서비스">CloudWatch 이벤트에서 자동으로 트리거 할수 있는 서비스</h2><ul><li>AWS Lambda 함수 호출</li><li>Amazon EC2 Run Command 호출</li><li>Amazon Kinesis Data Streams로 이벤트 릴레이</li><li>AWS Step Functions 상태 머신 활성화</li><li>Amazon SNS 주제 또는 Amazon SQS 대기열 알림</li></ul><h1 id="cloudwatch-이벤트를-amazon-ec2에-사용하는-몇-가지-예">CloudWatch 이벤트를 Amazon EC2에 사용하는 몇 가지 예</h1><ul><li>새로운 Amazon EC2 인스턴스를 시작할 때마다 Lambda 함수를 활성화합니다.</li><li>Amazon EBS 볼륨을 생성하거나 수정할 때 Amazon SNS 주제를 알립니다.</li><li>다른 AWS 서비스에서 특정 이벤트 발생 시 Amazon EC2 Run Command를 사용하여 명령을 하나 이상의 Amazon EC2 인스턴스에 전송합니다.</li></ul><h1 id="aws-cloudtrail을-사용하여-amazon-ec2-및-amazon-ebs-api-호출-로깅">AWS CloudTrail을 사용하여 Amazon EC2 및 Amazon EBS API 호출 로깅</h1><ul><li>cloudTrail은 콘솔의 호출 및 API 코드 호출 등 Amazon EC2 및 Amazon EBS에 대한 모든 API 호출을 이벤트로 캡처</li></ul><h1 id="일반적인-문제-해결-정보-및-질문">일반적인 문제 해결 정보 및 질문</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;영역5-운영-면에서-탁월한-아키텍처-정의&quot;&gt;영역5 : 운영 면에서 탁월한 아키텍처 정의&lt;/h1&gt;
&lt;h1 id=&quot;cloudwatch-이벤트를-사용한-amazon-ec2-자동화&quot;&gt;CloudWatch 이벤트를 사용한 Amazon EC2 자동화
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cloud/AWS/Exam/part4</title>
    <link href="https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Exam/part4/"/>
    <id>https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Exam/part4/</id>
    <published>2020-02-14T06:22:35.437Z</published>
    <updated>2020-02-15T08:35:08.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="영역4-비용에-최적화된-아키텍처-설계">영역4 - 비용에 최적화된 아키텍처 설계</h1><h1 id="비용-최적화-단계">비용 최적화 단계</h1><ul><li>가장 낮은 비용으로 용량 요구 사항을 충족하도록 적절하게 서비스 규모 조정</li><li>예약시 비용 절감</li><li>스팟 시장 사용</li><li>서비스 사용 모니터링 및 추적</li><li>Cost Explorer를 사용하여 비용 절감 최적화</li></ul><h1 id="서비스의-올바른-크기-조절-유형">서비스의 올바른 크기 조절 유형</h1><ul><li>EC2는 각 사용 사례에 맞게 최적화된 다양한 인스턴스 유형을 제공</li><li>인스턴스 유형은 CPU, 메모리 스토리지 및 네트워킹 용량의 다양한 조합으로 구성되며, 애플리케이션에 따라 적합한 리소스 조합 선택</li></ul><h3 id="인스턴스-유형-범용">인스턴스 유형 - 범용</h3><ul><li>범용 인스턴스는 균형있는 컴퓨팅, 메모리 및 네트워킹 리소스 제공</li><li>다양한 여러 워크로드에 사용</li><li>웹 서버 및 코드 리포지토리와 같이 이러한 리소스를 동등한 비율로 사용하는 어플리케이션에 적합<br><img src="../../../../image/2020-02-15-17-05-01.png" alt=""></li></ul><h3 id="인스턴스-유형-컴퓨팅-최적화">인스턴스 유형 - 컴퓨팅 최적화</h3><ul><li>고성능 프로세서를 활용하는 컴퓨팅 집약적인 애플리케이션에 적합</li><li>배치 처리 워크로드, 미디어 트랜스코딩, 고성능 웹 서버, HPC(고성능 컴퓨팅), 과학적 모델링, 전용 게임 서버 및 광고 서버 엔진, 기계 학습 추론 및 기타 컴퓨팅 집약적인 애플리케이션에 매우 적합<br><img src="../../../../image/2020-02-15-17-05-53.png" alt=""></li></ul><h3 id="인스턴스-유형-메모리최적화">인스턴스 유형 - 메모리최적화</h3><ul><li>메모리 최적화 인스턴스는 메모리에서 대규모 데이터 세트를 처리하는 워크로드를 위한 빠른 성능을 제공하기 위해 설계되었습니다.<br><img src="../../../../image/2020-02-15-17-06-30.png" alt=""></li></ul><h3 id="인스턴스-유형-가속화된-컴퓨팅">인스턴스 유형 - 가속화된 컴퓨팅</h3><ul><li>가속화된 컴퓨팅 인스턴스는 하드웨어 액셀러레이터 또는 코프로세서를 사용하여 부동 소수점 수 계산이나 그래픽 처리, 데이터 패턴 일치 등의 기능을 CPU에서 실행되는 소프트웨어보다 훨씬 효율적으로 수행합니다.<br><img src="../../../../image/2020-02-15-17-07-18.png" alt=""></li></ul><h1 id="인스턴스-유형-스토리지-최적화">인스턴스 유형 - 스토리지 최적화</h1><ul><li>로컬 스토리지에서 매우 큰 데이터 세트에 대해 많은 순차적 읽기 및 쓰기 액세스를 요구하는 워크로드를 위해 설계되었습니다. 이러한 인스턴스는 애플리케이션에 대해 지연 시간이 짧은, 수만 단위의 무작위 IOPS(초당 I/O 작업 수)를 지원하도록 최적화되었습니다.<br><img src="../../../../image/2020-02-15-17-07-58.png" alt=""></li></ul><h2 id="스토리지-클래스">스토리지 클래스</h2><ul><li>Amazon S3는 전체 수명 주기 동안 데이터를 관리할 수 있는 기능도 제공합니다. S3 수명 주기 정책을 설정한 후에는 애플리케이션 변경 없이 데이터가 다른 스토리지 클래스로 자동으로 전송됩니다.</li></ul><h3 id="amazon-s3-standard-s3-standard">Amazon S3 Standard(S3 Standard)</h3><ul><li>자주 액세스하는 데이터를 위해 높은 내구성, 가용성 및 성능을 갖춘 객체 스토리지를 제공</li><li>짧은 지연 시간과 많은 처리량을 제공하므로 클라우드 애플리케이션, 동적 웹 사이트, 콘텐츠 배포, 모바일 및 게임 애플리케이션, 빅 데이터 분석 등의 다양한 사용 사례에 적합</li><li>S3 수명 주기 정책을 사용하여 애플리케이션 변경 없이 자동으로 스토리지 클래스 간에 객체를 전환할 수 있습니다.</li></ul><h3 id="amazon-s3-intelligent-tiering-s3-intelligent-tiering">Amazon S3 Intelligent-Tiering(S3 Intelligent-Tiering)</h3><ul><li>성능 영향 또는 운영 오버헤드 없이 가장 비용 효과적인 액세스 계층으로 데이터를 자동으로 이동하여 비용을 최적화하기 위해 설계</li><li>두 개의 액세스 계층에 객체를 저장<ul><li>한 계층은 빈번한 액세스에 맞게 최적화</li><li>다른 한 계층은 빈번하지 않은 액세스에 맞게 최적화</li></ul></li><li>수명이 길고 액세스 패턴을 알 수 없거나 예측할 수 없는 데이터에 이상적</li></ul><h3 id="amazon-s3-standard-infrequent-access-s3-standard-ia">Amazon S3 Standard-Infrequent Access(S3 Standard-IA)</h3><ul><li>S3 Standard-IA는 자주 액세스하지 않지만 필요할 때 빠르게 액세스해야 하는 데이터에 적합</li><li>낮은 비용과 높은 성능의 조합을 제공하는 S3 Standard-IA는 장기 스토리지, 백업 및 재해 복구 파일용 데이터 스토어에 이상적</li></ul><h3 id="amazon-s3-one-zone-infrequent-access-s3-one-zone-ia">Amazon S3 One Zone-Infrequent Access(S3 One Zone-IA)</h3><ul><li>S3 Standard 또는 S3 Standard-IA 스토리지와 같은 가용성 및 복원력이 필요 없는 고객에게 적합</li><li>온프레미스 데이터 또는 쉽게 다시 생성할 수 있는 데이터의 보조 백업 복사본을 저장하는 경우</li></ul><h3 id="amazon-s3-glacier-s3-glacier">Amazon S3 Glacier(S3 Glacier)</h3><ul><li>온프레미스 솔루션과 비슷하거나 더 저렴한 비용으로 원하는 양의 데이터를 안정적으로 저장</li></ul><h3 id="amazon-s3-glacier-deep-archive-s3-glacier-deep-archive">Amazon S3 Glacier Deep Archive(S3 Glacier Deep Archive)</h3><ul><li>Amazon S3에서 가장 저렴한 비용의 스토리지 클래스</li><li>1년에 한두 번 정도 액세스할 수 있는 데이터의 장기 보관 및 디지털 보존을 지원</li><li>백업 및 재해 복구 사용 사례에도 사용할 수 있으며 온프레미스 라이브러리든 오프프레미스 서비스든 상관없이 자기 테이프 시스템에 대한 비용 효과적이고 관리하기 쉬운 대안</li></ul><h1 id="예약을-통한-비용-절감">예약을 통한 비용 절감</h1><ul><li>예약 인스턴스는 전체 선결제(AURI), 부분 선결제(PURI) 또는 선결제 없음(NURI)이라는 3가지 옵션으로 제공</li><li>예약 용량을 사용함으로써 조직은 위험을 최소화하고, 예산을 좀 더 예측 가능하게 관리하며, 장기 약정을 요구하는 정책을 준수</li></ul><h1 id="스팟-시장-사용">스팟 시장 사용</h1><ul><li>Amazon EC2 컴퓨팅 예비 용량에 입찰</li><li>같은 예산으로 애플리케이션의 컴퓨팅 파워와 처리 속도를 높이며, 새로운 유형의 클라우드 컴퓨팅 애플리케이션을 실행</li></ul><h1 id="cloud-watch">Cloud Watch</h1><ul><li>Amazon CloudWatch를 사용하여 지표를 수집 및 추적하고, 로그 파일을 모니터링하며, 경보를 설정하고, AWS 리소스 변경에 자동으로 대응할 수 있습니다. 또한 Amazon CloudWatch를 사용하여 시스템 전반의 리소스 사용률, 애플리케이션 성능, 운영 상태 파악</li></ul><h1 id="trusted-advisor">Trusted Advisor</h1><ul><li>리소스를 프로비저닝하여 시스템 성능과 안정성을 높이고, 보안을 강화하며, 비용을 절감할 기회를 모색할 수 있습니다. 또한 늘어나거나 줄어드는 수요를 충족하기 위해 비프로덕션 인스턴스를 끄고 Amazon CloudWatch 및 Auto Scaling을 사용할 수도 있습니다.</li></ul><h1 id="cost-explorer">Cost Explorer</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;영역4-비용에-최적화된-아키텍처-설계&quot;&gt;영역4 - 비용에 최적화된 아키텍처 설계&lt;/h1&gt;
&lt;h1 id=&quot;비용-최적화-단계&quot;&gt;비용 최적화 단계&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;가장 낮은 비용으로 용량 요구 사항을 충족하도록 적절하게 서비스 규모 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cloud/AWS/Exam/part3</title>
    <link href="https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Exam/part3/"/>
    <id>https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Exam/part3/</id>
    <published>2020-02-14T05:23:16.230Z</published>
    <updated>2020-02-14T07:17:03.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="영역3-안전한-애플리케이션-및-아키텍처">영역3: 안전한 애플리케이션 및 아키텍처</h1><h1 id="클라우드-보안-모범-백서">클라우드 보안 모범 백서</h1><ul><li>IAM 서비스 이용 : IAM으로 사용자가 어떤 AWS 서비스와 리소스에 액세스 할 수 있는지를 제어하는 암호, 액세스 키 및 사용권한 정책과 같은 보안 자격 증명을 한 곳에서 관리할 수 있다.</li></ul><h1 id="인프라-서비스의-책임-분담-모델">인프라 서비스의 책임 분담 모델</h1><p><img src="../../../../image/2020-02-14-14-25-16.png" alt=""></p><ul><li>AWS 보안 글로벌 인프라를 바탕으로 자체 데이터 센터에서 온프레미스로 하는 것과 같은 방식으로 AWS클라우드에서 운영체제와 플랫폼을 설치 및 구성</li><li>불투명 계층에서 데이터 암호화, 인증 등 추가로 보안을 요구할 수 있다.</li><li>AMI에서 EC2접속 키를 발급받으면 사용자는 이를 안전하게 보관해야 하며,  AWS 내에서는 Private key가 저장되지 않는다.</li></ul><h1 id="컨테이너-서비스의-책임-분담-모델">컨테이너 서비스의 책임 분담 모델</h1><p><img src="../../../../image/2020-02-14-14-29-31.png" alt=""></p><ul><li>AWS 가 플랫폼 및 애플리케이션 관리까지 함.</li><li>AWS 컨테이너 서비스의 경우 컨테이너 서비스 액세스를 위한 데이터와 방화벽 규칙에 대한 책임은 고객에게 있다.</li></ul><h1 id="aws에서-자산정의-및-분류">AWS에서 자산정의 및 분류</h1><ul><li>자산, 카테고리, 비용을 결정한 후, AWS에서 정보 보안 관리 시스템(ISMS)를 구현, 운영, 모니터링, 검토, 유지 보수, 개선하기 위한 표준을 설정</li><li>비즈니스 요건과 목표, 사용하는 프로세스, 조직의 크기와 구조에 따라 달라짐</li></ul><h1 id="aws에서-계정-iam-사용자-그룹-역할-관리">AWS에서 계정, IAM 사용자, 그룹 역할 관리</h1><ul><li>Root 계정은 매우 강력한 권한이 있기 때문에 일반 업무시 사용하지 않는 것을 권장.</li><li>IAM 사용자로 개별적인 사용자와 보안 그룹은 분리해 각 개인 그룹별 사용자로 구분하여 권한 제한을 하는 것이 좋음</li></ul><h1 id="aws-인프라-보안">AWS 인프라 보안</h1><ul><li>물리적 환경적 보안 : AWS직원의 데이터 센터에 대한 물리적 접근은 모두 기록되며 정기적으로 감사를 받으며, 여러 안전 대책에 의해 데이터 센터가 안전하게 보호됨.</li><li>연속성 관리 : 모든 데이터 센터는 온라인으로 고객에게 서비스를 제공하며, 어떤 데이터 센터도 정지 되지 않음. 또한 전 세계에 데이터 센터가 분산되어 있어 높은 가용성을 가진다.</li><li>보안 네트웤 아키텍처 : AWS는 DDOS, MITM, IP Spoofing, 포토 스캐닝, 패킷 스니핑 등의 공격 방어를 위해 강력한 보안 결함 차단 방식을 지원.</li></ul><h1 id="aws-계정-보안-기능">AWS 계정 보안 기능</h1><ul><li>AWS IAM : AWS 계정 내에서 여러 사용자를 생성하고, 이러한 사용자 각각의 권한을 관리, 임시 보안 자격 증명을 사용하여 제한된 시간 동안만 유효한 보안 자격 증명을 통해 보안 AWS리소스에 대한 임시 액세스를 사용자에게 제공</li><li>AWS MFA : 표준 사용자 이름과 암호 자격 증명 외에 6자리 일회용 코드를 입력해야 고객의 AWS계정 설정 또는 AWS 서비스 및 리소스 액세스 권한이 부여됨, 하드웨어 토큰 및 가상 MFA 디바이스의 사용을 모두 지원</li></ul><h1 id="aws-서비스별-보안">AWS 서비스별 보안</h1><ul><li><p>AWS EC2 의 보안</p><ul><li>하이퍼바이저를 이용하며, 리눅스 게스트의 경우는 반가상화를 활용, 고급 권한에 대한 통제를 한다.</li><li>하이퍼바이저를 통해 인스턴스는 물리적으로 상호 격리되어 보안성을 올린다.<br><img src="../../../../image/2020-02-14-14-44-09.png" alt=""></li><li>가상 인스턴스는 오직 고객만 제어 할 수 있으며 전체 루트 액세스 또는 관리 제어 권한을 가진다. AWS는 고객의 인스턴스 또는 게스트 OS에 대한 어떤 액세스 권한도 접근할 수 없다.</li><li>방화벽 : EC2의 인바운드 방화벽은 기본적으로 모두 거부 모드로 구성되며, 사용자가 인바운드 트래픽을 허용하는 데 필요한 포트를 임의로 개방해야함.</li><li>예시: 웹 서버 그룹에는 인터넷에 개방된 포트 80(HTTP) 및/또는 포트 443(HTTPS)을 개방</li><li>애플리케이션 서버 그룹에는 웹서버 그룹에만 액세스 할 수 있는 8000번 포트로 구성</li><li>데이터베이스 서버 그룹에는 애플리케이션 서버 그룹에만 개방된 3006번 포트로 구성</li><li>세그룹 모두 22에 대한 관리 액세스는 허용하나, 고객의 기업 네트워크에서만 가능하게 특정 IP 대역만 잡속하도록 함.</li></ul></li><li><p>AWS EBS 보안</p><ul><li>AWS EBS 볼륨에 대한 접근은 해당 볼륨을 생성한 AWS계정 및 IAM을 이용해 만든 AWS 계정 사용자로 제한되므로, 다른 모든 AWS계정 및 사용자에게는 볼륨을 보거나 접근하는 권한이 거부된다.</li><li>AWS EBS에 저장된 데이터는 정상적인 서비스를 위해 물리적으로 여러 지점에 중복 보관된다.</li></ul></li><li><p>AWS Elastic Load Balancing 보안</p><ul><li>Elastic Load Balancing은 온프레미스 로드 벨런서의 모든 장점 이외에 여러 가지 보안상 이점을 제공한다.</li><li>EC2 인스턴스를 대신해 암호화 및 복호화 작업을 수행 및 로드 밸런서에서 중앙집중식으로 관리 가능</li><li>클라이언트에 단일 접점을 제공하며 네트워크 공격에 대한 1차 방어선 역할도 수행</li><li>AWS VPC를 사용하는 경우, ELB에 연결된 보안 그룹의 생성 및 관리를 지원하여 추가적인 네트워킹 및 보안 옵션을 제공</li><li>보안(HTTPS/SSL) 연결을 사용하는 네트워크에서 종단 간 트래픽 암호화를 지원</li></ul></li><li><p>AWS VPC 보안</p><ul><li>AWS VPC를 사용하면 AWS 클라우드의 격리된 부분을 만들고, 선택한 범위에 프라이빗 주소가 있는 AWS　EC2 인스턴스를 시작 할 수 있다.</li><li>각 AWS VPC에서의 네트워크 트래픽은 다른 모든 AWS VPC와 격리됨.</li><li>AWS　VPC는 인스턴스의 진출입 트래픽을 모두필터링 할 수 있는 완전한 방화벽 솔루션을 지원</li><li>네트워크 ACL: AWS VPC내 서브넷에서 인바운드 또는 아웃바운드하는 모든 트래픽에 적용되는 상태 비저장 트래픽 필터, 이러한 ACL은 IP 프로토콜, 서비스 포트, 원본/대상 IP 주소에 따라 트래픽을 허용 또는 거부하는 규칙을 포함함</li></ul></li><li><p>AWS S3 보안</p><ul><li>기본적으로 저장된 데이터에 대한 액게스는 제한됨, 버킷 및 객체 소유자에게만 자신이 생성한 AWS S3 리소스에 접근할 수 있다.</li><li>객체 접근에 대한 액세스 제어는 IAM, ACL, 버킷정책으로 할 수 있으며, 특정 조건을 기준으로 특정 리소스에 대한 액세스를 추가로 제한 할 수 있다.<br><img src="../../../../image/2020-02-14-14-57-20.png" alt=""></li><li>데이터 저장시 S3 암호화 클라이언트와 같은 클라이언트 암호화 라이브러리를 사용하여 데이터를 암호화 한 후에 업로드 할 수 있으며, 장기 저장시 S3버킷의 콘텐츠를 Glacier에 자동으로 보관 할 수 있다.</li><li>Amazon S3는 연간 99.999999999%의 객체 내구성과 99.99%의 가용성을 제공하도록 설계되었으며, 버전 관리 및 액세스 로그 열람으로 추가적인 보안을 제공한다.</li></ul></li><li><p>AWS Glacier 보안</p><ul><li>AWS Glacier는 파일을 아카이브 단위로 볼트 내에 저장.</li><li>특정한 간격으로 Glacier에 데이터를 전송하도록 S3를 설정 할 수 있으며, 더 높은 수준의 보안을 달성하기 위해 SSL암호화 엔드포인트를 통해 AWS Glacier에 안전하게 데이터를 업로드 하거나 다운로드 할 수 있다.</li></ul></li><li><p>AWS RDS 보안</p><ul><li>AWS RDS내에서 처음 DB인스턴스를 생성할 경우 DB 인스턴스에 대한 액세스를 제어하기 위해 AWS RDS안에서만 사용되는 사용자 계정을 만든다. 이후 추가로 계정 생성 가능</li><li>AWS VPC에 배포된 DB인스턴스는 VPN 또는 퍼블릭 서브넷에서 실행 할 수 있는 베스천 호스트를 통해 VPC 외부의 AWS EC2 인스턴스에서 액세스 할 수 있다.</li><li>SSL을 사용하여 애플리케이션과 DB인스턴스 사이의 연결을 암호화 하여 보안수준을 높일 수 있지만, DB 연결 지연시간을 늘리는 단점 이있다.</li><li>AWS RDS는 DB인스턴스 백업 및 복구를 위한 자동 백업 및 데이터베이스 스냅샷(DB스냅샷)을 제공한다.</li></ul></li><li><p>Amazon CloudFront 보안</p><ul><li>Amazon CloudFront는 대상 API에 대한 모든 요청에 대해 인증을 요구하며 허가 받은 사용자만 Amazon CloudFront에서 배포하는 정보를 생성, 변경, 또는 삭제할 수 있도록 한다.</li><li>Amazon CloudFront 로부터 콘텐츠를 다운로드 할 수 있는 사람들을 제한하고자 할 경우, 서비스의 콘텐츠 비공개 기능을 사용하도록 설정할 수 있다.</li><li>Amazon CloudFront엣지에서 Amazon S3에 있는 고객 소유 객체에 액세스하는 방법을 제어하거나, 두번째　Amazon CloudFront엣지에서 인터넷의 최종 사용자에게 콘텐츠를 전달하는 방법을 제어한다.</li><li>또한 웹 어플리케이션에 지리적 제한 로직을 추가함으로써 최종 사용자의 지리적 위치에 따라 콘텐츠에 대한 액세스를 차단하도록 사용자 지정 할 수 있다.</li><li>Amazon CloudFront는 사용자에게 전달되는 콘텐츠를 인증할 수 있도록 암호화된 연결 (HTTPS)을 통해 콘텐츠를 전달하는 기능을 제공한다. Amazon CloudFront 기본적으로 HTTP 및 HTTPS프로토콜을 통해 요청을 수락하며, 필요한 경우 모든요청에 대해 HTTPS를 요구하고 HTTP요청은 모두 허용하지 않도록 Amazon CloudFront를 설정할 수도 있다.</li><li>Amazon CloudFront에서 고유의 도메인 이름을 사용하려면 SSL인증서를 AWS IAM인증서 스토리지에 업로드한 후 해당 인증서를 Amazon CloudFront 배포에 연결해야 한다.</li></ul></li></ul><h1 id="aws-security-by-design">AWS Security by Design</h1><ul><li>Security by Design?<ul><li>여러 산업계, 표준 및 보안 기준 전체에서 대규모의 보안 및 규정 준수를 유지하기 위한 4단계 접근법<ul><li>수정 권한이 없는 사용자가 재정의할 수 없는 강제 기능 생성.</li><li>안정적인 제어 작업 구축</li><li>지속적인 실시간 감사 기능.</li><li>거버넌스 정책을 스크립팅하는 기술</li></ul></li></ul></li></ul><h1 id="aws-환경에서의-보안">AWS 환경에서의 보안</h1><ul><li>AWS 클라우드에서 시스템을 배포할 때는 AWS 및 고객이 보안 책임을 공동으로 부담한다. AWS는 기반 인프라에 대한 보안을 담당하는 반면, 사용자는 AWS에 배포된 IT리소스에 대한 보안을 담당한다.</li><li>Security by Design  접근법은 4단계로 구성되어 있다.<ul><li>1단계 : 요구사항 확인</li><li>2단계 : 요구사항 및 구현 조건에 맞는 “골드환경” 구축.</li><li>3단계 : 템플릿 사용설정.</li><li>4단계 : 검증작업 수행.</li></ul></li><li>1단계 - 요구사항 확인<ul><li>먼저 보안 제어 합히화 작업을 수행하며, 현재 고객 아키택처에 최적화되어 운영중인 제어를 식별하고, 기존 AWS인증내역, 승인 및 보고서로 부터도 참조할 내역을 식별하여 보안 Controls Implementation Matrix(CIM)를 생설 할   수 있다.</li></ul></li><li>2단계 - “골드환경” 구축<ul><li>이단게는 사용자가 AWS가 제공하는 광범위한 보안 및 감사 서비스와 기능을 서로 연결하고, 보안, 규정 준수 및 감사 담당자에게 보안 및 규정 준수 환경을 구성하는 간단한 방법을 제공하도록 한다.</li><li>IAM으로 액세스 관리, VPC나 subnet을 이용한 네트워크 분할, 리로스 제약 조건 및 모니터링, 데이터 암호화를 통해 기능을 연결 할 수 있다.</li><li>AWS GoldBase : AWS GoldBase는 특정 보안/규정 준수 요구 사항 내에서 사전 점검되고 자동화된 참조 아키텍처를 제공한다. AWS GoldBase 사용 사례 패키지는 기준 CloudFormation 템플릿으로 구성되는데, 사용자는 이를 고객 환경 내 배포용으로 사용자 지정할 수 있다. 자세한 내용은 “AWS GoldBase 소개” 백서 참조</li></ul></li><li>3단계 - 템플릿 사용 설정<ul><li>“골드 환경”을 만든 후에는 AWS에서 이를 사용할 수 있도록 설정해야 하는데, 서비스 카탈로그를 설정하여 이를 수행할 수 있다.</li><li>서비스 카탈로그를 설정하면 계정에 액세스하는 모든 사용자가 만들어진 CloudFormation 템플릿을 사용하여 자신의 환경을 만들어야 한다.</li><li>사용자가 환경을 사용할 때마다 이러한 “골드 환경” 규칙이 모두 적용되어, 제어의 나머지 고객 계정 보안 구성을 효과적으로 조작할 수 있으므로 감사에 대비할 수 있다</li></ul></li><li>4단계 - 검증작업 수행<ul><li>이 단계의 목표는 AWS 고객이 일반적으로 용인되는 공공 감사 표준을 기준으로 독립적인 감사를 지원할 수 있도록 하는 것.</li><li>AWS는 규정을 준수하지 않는 인스턴스가 실제로 있는지 여부를 감지하는 AWS Config를 제공하며, AWS Config는 아키텍처의 현재 시점 설정정보를 제공한다.</li><li>또한 AWS는 보안된 읽기 액세스를 통해 여러 감사 증거 수집 기능과 증거 모음을 자동으로 감사하는 고유 API 스크립트를 함께 제공한다.</li></ul></li></ul><h1 id="aws-iam-모범사례">AWS IAM 모범사례</h1><h1 id="aws-계정-루트-사용자-액세스-키-잠금">AWS 계정 루트 사용자 액세스 키 잠금</h1><ul><li>AWS 계정 루트 사용자 액세스 키는 사용하면 안된다.</li><li>만약 그 계정의 루트 액세스 키카 탈취 되면 계정과 연관된 모든 정보, 신용카드정보 유출</li></ul><h1 id="개별-iam-사용자-만들기">개별 IAM 사용자 만들기</h1><ul><li>루트 자격 증명을 사용하여 액세스 하는 것은 안되며, 관리자 IAM을 생성하여 액세스해야하는 계정에 별도의 사용자 계정을 만드는 것이 권장된다.</li><li>또한 그룹을 사용하여 사용자 그룹에 대한 정의를 만들어 그룹권한을 설정하는 것이 관리하기 더 편하다.</li><li>IAM정책을 개인이나 그룹에 적용 할 때는 작업 수행에 필요한 최소한의 권한을 주어 다른 서비스 접근을 못하게 한다.</li></ul><h1 id="엑세스-레밸을-이용한-iam-권한-검토">엑세스 레밸을 이용한 IAM 권한 검토</h1><ul><li>AWS은 작업 내용에 따라 각 서비스 작업을 다섯개의 액세스 레밸 즉, List, Read, Write, Permissions management, Tagging 중 하나로 분류한다. 이러한 액세스 레벨을 사용하여 어떤 작업을 정책에 포함할지 결정 할 수 있다.</li></ul><h1 id="권한있는-사용자에-대해-mfa-활성화">권한있는 사용자에 대해 MFA 활성화</h1><ul><li>보안을 강화하기 위해 중요한 리소스 또는 API작업에 대해 액세스 권한이 부여된 IAM 사용자에 대해 멀티 팩터 인증을 적용</li><li>가상 핸드폰이나 실제 디바이스가 코드 생성하면 그번호를 입력해야 로그인 할 수 있다.</li></ul><h1 id="aws-게정의-활동-모니터링">AWS 게정의 활동 모니터링</h1><ul><li>AWS의 로깅 기능을 사용하여 사용자가 계정에서 수행한 작업과 사용한 리소스를 확인하여 보안 수준을 올린다.</li><li>로그 파일에는 작업 시간 및 날짜, 작업의 소스 IP, 부족한 권한으로 인해 실패한 작업등이 나와 있다. 이러한 기록을 통해 비 정상적인 접근이 있는지 확인 가능하다.</li></ul><h1 id="보안-서비스-amazon-vpc">보안 서비스 - Amazon VPC</h1><h1 id="vpc-개념">VPC 개념</h1><ul><li>VPC는 사용자의 AWS계정 전용 가상 네트워크</li><li>VPC는 AWS 클라우드에서 다름 가상 네트워크와 논리적으로 분리되어 있으며, Amazon EC2 인스턴스와 같은 AWS 리소스를 VPC에서 실행 할 수 있다.</li><li>서브넷: VPC의 IP 주소 범위, 지정된 서브넷으로 AWS리소스를 시작할 수 있다. 인터넷에 연결되어야 하는 리소스에는 퍼블릭 서브넷을, 인터넷에 연결되지 않는 리소스에는 프라이빗 서브넷을 사용한다.</li></ul><h1 id="인터넷-액세스">인터넷 액세스</h1><p><img src="../../../../image/2020-02-14-15-46-53.png" alt=""></p><ul><li>기본적으로 기본이 아닌 서브넷에서 시작한 인스턴스 프라이빗 Ipv4 주소가 있으며, 시작 시 특별히 지정하지 않는 한 퍼블릭 IPv4주소는 없다. 이러한 인스턴스는 서로 통신 할 수는 있지만 인터넷 액세스 할 수는 없다.</li></ul><p><img src="../../../../image/2020-02-14-15-49-27.png" alt=""></p><ul><li>기본이 아닌 서브넷에서 시작한 인스턴스에 대해 해당 VPC에 인터넷 게이트웨이를 추가하고(해당 VPC가 기본 VPC가 아닐 경우)인스턴스에 탄력적 IP 주소를 연결하여 인터넷 액세스를 가능하게 할 수 있다.</li></ul><p><img src="../../../../image/2020-02-14-15-52-03.png" alt=""></p><ul><li>원할 경우 IPsec AWS Site-to-Site VPN연결을 사용하여 VPC를 회사의 데이터 선터에 연결함으로써 회사 데이터 센터를 AWS 클라우드로 확장 할 수 있다.</li><li>Site-to-Site VPN 연결은 VPC에 추가된 가상 프라이빗 게이트웨이와 데이터 센터에 위치하는 고객 게이트 웨이로 구성된다.</li></ul><h1 id="핵심-amazon-ec2-및-s3-보안-기능-집합">‘핵심’ Amazon EC2 및 S3 보안 기능 집합</h1><h1 id="amazon-s3-리소스에-대한-액세스-권한-관리">Amazon S3 리소스에 대한 액세스 권한 관리</h1><ul><li>기본적으로 버킷, 객체 및 관련 하위 리소스를 비롯한 모든 아마존 s3리소스는 비공개이다. 즉, 리소스를 만든 AWS 계정인 리소스 소유자만 해당 리소스에 액세스 가능하다.</li><li>리소스 기반 정책, 사용자 정책 또한 이러한 정책의 조합을 사용하도록 선택하여 Amazon S3 리소스에 대한 권한을 관리 할 수 있다.</li><li>ACL : 각 버킷과 객체마다 연결된 ACL이 존재, ACL로 다른 AWS 계정에 기본적인 읽기/쓰기 권한을 부여한다.<br><img src="../../../../image/2020-02-14-15-58-32.png" alt=""></li><li>버킷정책 : 본인의 버킷에 한해 다른 AWS 계정이나 IAM 사용자에게 버킷과 버킷에 포함된 객체에 대한 권한을 부여하는 버킷 정책을 추가 할 수 있다.</li><li>버킷정책은 ACL기반 액세스 정책을 보완하여 대부분의 경우 액세스 정책을 대신한다.<br><img src="../../../../image/2020-02-14-15-58-48.png" alt=""></li><li>사용자 정책 : IAM로 Amazon S3 리로스에 대한 액세스를 관리 할 수 있다.</li><li>내 계정으로 IAM 사용자, 그룹, 역할을 만들고 액세스 정책을 연결하면 Amazon S3등 AWS리소스에 액세스 가능하다.</li></ul><h1 id="ddos-완화">DDos 완화</h1><h1 id="ddos-대응을-위한-aws-모범-사례">DDos 대응을 위한 AWS 모범 사례</h1><ul><li>DDos 공격 : 최종 사용자(End User)가 여러분의 웹 사이트나 어플리케이션을 이용할 수 없도록 만드는것, 대표적으로 네트워크나 다른 자원들을 고갈시켜 사용자의 정당한 요청을 처리할 수 없게끔 만들어 버림.</li></ul><h1 id="ddos-완화-기법들">DDos 완화 기법들</h1><p><img src="../../../../image/2020-02-14-16-04-10.png" alt=""></p><ul><li>ELB와 EC2와 같은 AWS리전 내부의 서비스들은 해당 리전 내에서 예상치 못한 트래픽의 볼륨을 다룰 수 있게끔, 확장하는 방식으로 DDos대응력을 확볼 할 수 있다.</li><li>Amazon CloudFront, AWS WAF, Amazon Route 53, Amazon API Gateway 같은 엣지 로케이션에 제공되는 서비스를 이용하면, 글로벌 네트웍 커버리지를 이용하여 장애 대응력을 확보 할 수 있다.</li><li>인스턴스 사이즈 조절 : 필요한 만큼 인스턴스들을 어플리케이션 환경에 추가하는 방식으로 수평적으로 확장하거나, 좀더 큰 인스턴스로 수직 확장시키는 방법을 선택할수있다.</li><li>엣지에서 도메인 이름 변환하기 : Amazon Route53은 셔플 샤딩과 애니캐스트 스트라이핑 기능을 사용하여, Route53이 DDos공격을 받더라도, 사용자가 여러분의 어플리케이션에 접근 할 수 있게 해준다.</li><li>셔플샤딩: 위임 집합(delegation set) 내의 각 네임 서버들에 대해 엣지 로케이션들과 인터넷 경로들을 묶은 집합을 대응시켜주는 기능</li><li>공격 지점 줄이기: 리소스이 전혀 최종 사용자들과 직접적인 상호 작용을 하지 않는다면, 해당 리소스들이 인터넷과의 직접적인 접근을 갖지 않도록 해야함.</li><li>AWS 리소스 감추기: 대부분의 어플리케이션에서는 AWS 리소스들이 인터넷 상에 완전히 노출될 필요가 없다. 예를 들어, ELB 뒷 단에 있는 Amazon EC2 인스턴스들은 인터넷 상에서 바로 접근할 필요가 없다.</li><li>이런 구성은 Amazon Virtual Private Cloud(VPC) 내부의 보안 그룹(Security Group)과 네트웍 접근제어 목록(NCAL)을 설정하면 된다.</li><li>보안 그룹: 인터넷으로부터 보안 그룹으로의 모든 트래픽들은 여러분들이 명시적으로 해당 트래픽을 허용해주지 않으면 기본적으로 차단된다.</li><li>예를 들어, 하나의 ELB 와 여러 대의 Amazon EC2 인스턴스들로 웹 어플리케이션을 구성했을 때, ELB 에 적용할 단일 보안 그룹(‘ELB 보안 그룹’)을 적용할 지, 인스턴스 별로 여러 개의 서로 다른 보안 그룹(‘웹 어플리케이션 서버 보안 그룹’)을 적용할 지는 결정해야 한다</li><li>API 엔드 포인트를 보호하기: Amazon API Gateway 를 이용하게 되면, API 의 앞 단에 별도의 서버를 구성할 필요가 없으며, 어플리케이션 구성 요소들을 외부에서 잘 안보이도록 감출 수 있게 된다.</li><li>Amazon API Gateway 는 Amazon CloudFront 와 연계되어 있으며, 서비스가 자체적으로 DDoS 대응력을 갖출 수 있게끔 해주는 이점을 줄 수 있다.</li><li>운영 기법들- 가시성: Amazon CloudWatch 를 통해, AWS 상에서 운영되고 있는 어플리케이션들을 모니터링 할 수 있다.</li><li>VPC Flow logs: VPC Flow Logs 를 이용한다면, VPC 내의 네트웍 인터페이스들을 통해 주고받는 IP 트래픽에 대한 정보를 얻을 수 있다.</li></ul><h1 id="암호화-솔루션">암호화 솔루션</h1><h1 id="aws에서의-저장-데이터-암호화">AWS에서의 저장 데이터 암호화</h1><ul><li>암호화에 필요한 3가지 요소<ol><li>암호화할 데이터</li><li>데이터를 암호화하는 방법</li><li>데이터 및 알고리즘과 함께 사용될 키</li></ol></li><li>AWS 의 암호화 방법 3가지</li><li>사용자가 암호화 방법 및 전체 KMI 제어</li><li>사용자가 암호화 방법을 제어하고 AWS가 KMI 스토리지 구성요소를 제공, 사용자가 KMI관리 계층을 제공</li><li>AWS가 암호화 방법 및 전체 KMI 를 제어<br><img src="../../../../image/2020-02-14-16-12-09.png" alt=""></li></ul><h1 id="사용자가-암호화-방법-및-전체-kmi-제어">사용자가 암호화 방법 및 전체 KMI 제어</h1><ul><li>Amazon S3 : 사용자가 원하는 모든 암호화 방법을 사용하여 데이터를 암호화한 다음, Amazon Simple Storage Service(S3) API를 사용하여 암호화된 데이터를 업로드</li><li>AWS SDK에 포함되어 있는 오픈 소스 API 세트를 활용하여 암호화 가능</li><li>Amazon EBS: 인스턴스에 블록 디바이스로 제공되므로 파일 시스템 수준 또는 블록 수준 암호화를 위해 대부분의 표준 암호화 도구를 활용할 수 있다.</li></ul><h1 id="사용자가-암호화-방법-제어-aws가-kmi-스토리지-구성-요소-제공-및-사용자가-kmi-관리-계층-제공">사용자가 암호화 방법 제어, AWS가 KMI 스토리지 구성 요소 제공 및 사용자가 KMI 관리 계층 제공</h1><ul><li>사용자가 암호화 방법을 관리한다는 점에서 모델 A와 유사하지만, 키를 사용자가 온프레미스에서 관리하는 키 스토리지 시스템이 아닌 AWS CloudHSM 에 저장한다는 점이 모델 A와 다르다</li><li>HSM은 키 구성 요소를 생성하고 저장하는 데 사용할 수 있으며, 암호화 및 복호화 작업을 수행하지만, 키 수명 주기 관리 기능(예: 액세스 제어 정책, 키 로테이션)을 수행하지는 않는다.</li></ul><h1 id="aws가-암호화-방법-및-전체-kmi-제어">AWS가 암호화 방법 및 전체 KMI 제어</h1><ul><li>KMS: 관리형 암호화 서비스로, 키를 프로비저닝하고 사용하여 AWS 서비스에서 데이터 및 애플리케이션을 암호화하도록 해준다.</li><li>AWS KMS 및 데이터를 직접 암호화하는 기타 서비스는 봉투 암호화라는 방법을 사용하여 성능과 보안 간 균형을 유지</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;영역3-안전한-애플리케이션-및-아키텍처&quot;&gt;영역3: 안전한 애플리케이션 및 아키텍처&lt;/h1&gt;
&lt;h1 id=&quot;클라우드-보안-모범-백서&quot;&gt;클라우드 보안 모범 백서&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;IAM 서비스 이용 : IAM으로 사용자가 어떤 AWS
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cloud/AWS/Exam/part2</title>
    <link href="https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Exam/part2/"/>
    <id>https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Exam/part2/</id>
    <published>2020-02-14T05:02:01.213Z</published>
    <updated>2020-02-14T07:41:56.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="영역2-성능이-뛰어난-아키텍처-정의">영역2 : 성능이 뛰어난 아키텍처 정의</h1><h1 id="aws-elastcache">AWS ElastCache</h1><ul><li>클라우드 상에 메모리 기반으로 구성된 데이터 스토어 또는 캐시를 쉽게 운영할 수 있는 서비스 - In Memory 방식</li><li>Memcached 및 Redis와 호환되는 프로토콜이므로 기존 Memcached 또는 Redis환경에서 현재 사용하는 코드, 애플리케이션 및 주요도구를 Amazon ElasticCache에서 문제없이 사용 할 수 있다.</li></ul><h1 id="amazon-machine-image-ami">Amazon Machine Image : AMI</h1><ul><li>AMI란?<ul><li>인스턴스를 시작할 때 필요한 정보를 제공</li><li>AMI 생성 및 등록한 후 새 인스턴스 시작할 때 그 이미지를 사용할 수 있으며, 동일 리전 및 다른 리전에서도 사용할 수 있음</li><li>AMI를 퍼블릭으로 설정하여 외부와 공유할 수 있으며, AMI marketplace에서 AMI를 판매할 수 있다.</li></ul></li></ul><h1 id="사용자-인프라를-고려한-아키텍쳐-설계">사용자 인프라를 고려한 아키텍쳐 설계</h1><ul><li><p>사용자 &gt; 100</p><ul><li>기능에 따라 인스턴스 역할을 나눈다.<ul><li>웹 서버용 인스턴스</li><li>DB용 인스턴스<ul><li>편리한 DB 운영을 위해 Amazon RDS이용</li></ul></li></ul></li></ul></li><li><p>사용자 &gt; 1000</p><ul><li>Elastic Load Balaning : 확장성 높은 부하 분산 서비스</li><li>Multi AZ 서버 구성</li><li>데이터베이스 이중화<ul><li>RDS 의 기본 예비 복제본</li><li>Multi AZ에 구성</li></ul></li></ul></li><li><p>사용자 : 10,000 - 100,0000+</p><ul><li>기본 복제본과 읽기 전용 복제본(Read Replica)를 사용하여 데이터 접근 부하를 줄인다.</li><li>또한 정적 컨텐츠를 S3와 CloudFront로 이동하여 부하를 분산시킨다.</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;영역2-성능이-뛰어난-아키텍처-정의&quot;&gt;영역2 : 성능이 뛰어난 아키텍처 정의&lt;/h1&gt;
&lt;h1 id=&quot;aws-elastcache&quot;&gt;AWS ElastCache&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;클라우드 상에 메모리 기반으로 구성된 데이터 스토어 또는
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cloud/AWS/Exam/part1</title>
    <link href="https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Exam/part1/"/>
    <id>https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Exam/part1/</id>
    <published>2020-02-14T04:22:37.930Z</published>
    <updated>2020-02-14T07:30:15.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="영역-1-복원력을-갖춘-아키텍처-설계">영역 1: 복원력을 갖춘 아키텍처 설계</h1><h1 id="aws-인프라-구성">AWS 인프라 구성</h1><ul><li>전 세계 21개의 지리적 리전 내에 66새의 가용영역을 운용</li></ul><h1 id="region-의미">Region 의미</h1><ul><li>리전은 개별 지역 내 존재하는 지리적 위치</li></ul><h1 id="az-가용역역-의미">AZ (가용역역) 의미</h1><ul><li>가용영역은 리전 내 있는 구분된 가용성 영역 의미</li><li>전용선으로 연결되어 있어 한 클러스터처럼 동작</li></ul><h1 id="amazon-cloudfront-글로벌-엣지-네트워크">Amazon CloudFront 글로벌 엣지 네트워크</h1><ul><li>유저에게 짧은 지연시간으로 콘텐츠를 전송 할 수 있도록 해줌<ul><li>특징<ul><li>여러공격으로부터 네트워크 및 어플리케이션 계층을 보호 AWS Edge역할</li><li>가용성 향상을 위해 콘텐츠 캐싱 오리진 서버 부하 줄임</li><li>여러 오리진을 설정, 소스오리진 사용불가시 자동으로 백업 오리진 사용하도록 라우팅</li><li>프로그래밍 가능한 정식 API 제공</li></ul></li></ul></li></ul><h1 id="클라우드-서비스를-설계하는-방법">클라우드 서비스를 설계하는 방법</h1><ul><li>설계 포인트<ul><li>보안 : 전송 및 보관시 암호화, IAM으로 권한 관리, VPC로 인프라 보호, CloudWatch로 감시 제어 활동</li><li>안정성: 복구 절차 테스트 및 자동 복구 설정, 수평확장이 가능하도록 구성</li><li>성능 효율화: AWS에서 최신 기술 쉽게 사용하도록 지원, 글로벌 어플리케이션 지원 및 서버리스 아키텍처를 이용한 새로운 아이디어 실험</li><li>비용 최적화: 오토 스케일링을 통한 필요한 자원만 사용, 비용 효율적인 지원 사용</li></ul></li></ul><h1 id="aws-기반-마이크로-서비스-아키텍쳐-구현-방안">AWS 기반 마이크로 서비스 아키텍쳐 구현 방안</h1><ul><li>마이크로서비스란?<ul><li>작은 빌딩 블록, 높은 비결합성, 작은 작업 수행, 머듈식의 접근, 디자인 스타일</li><li>고려사항<ul><li>리소스관리: EC2 컨테이너를 사용해서 유연하고 AWS 응용이 쉬운 상태로 설계, Lamda를 사용하여 Serverless이벤트 처리 방식의 컴퓨팅 서비스 사용</li><li>모니터링: AWS CloudWatch</li><li>서비스 Discovery: EC2 와 Route53 사용</li><li>배포: Blue-green 배포, Lambda 배포 사용</li></ul></li></ul></li></ul><h1 id="느슨한-결합을-구현하기-위한-서비스들">느슨한 결합을 구현하기 위한 서비스들</h1><ul><li>ELB<ul><li>로드밸런서 선택 시 : 애플리케이션에 맞는 로드 밸런서 선택</li><li>Application load Balancer, Network load Balancer, Classic load balancer 를 적절히 사용</li><li>Application load balancer : HTTP, HTTPS, Websocket등 다양한 프로토콜 지원</li><li>하이브리드 로브 밸런싱 지원</li></ul></li><li>SQS<ul><li>메시지 대기열 시스템을 손쉽게 구축 가능, FIFO 대기열 사용</li><li>Amazon SNS와 차이점 - SNS는 폴링할 필요 하없이 푸쉬 메커니즘으로 메세지 전송, SQS에서는 폴링 모델로 메세지 교환</li><li>무조한 최초 1번은 전송을 한다.</li></ul></li></ul><h1 id="복원력을-갖춘-스토리지-선택하기">복원력을 갖춘 스토리지 선택하기</h1><p><img src="../../../image/2020-02-14-13-41-03.png" alt=""></p><ul><li>EC2 - Amazon EBS<ul><li>Amazon EBS : EC2에서 사용하는 일종의 하드 디스크로 다른 물리적 하드 드라이브처럼 사용가능, 다른 인스턴스에 EBS를 분리한 후 다른 인스턴스에 연결하는 것도 가능</li><li>인스턴스 스토어 : 휘발성 스토리지, 인스턴스가 활성화 되어 있는 동안 유지되는 스토리지, 상대적으로 성능이 낮으니 데이터 분석용으로 주로 사용</li><li>Amazon EFS : 인스턴스에 사용할 수 있는 간단하고 확장 가능한 파일 스토리지. 파일이 추가되고 제거됨에 따라 자동으로 증가하고 줄어든다. 저장 사용량만큼만 비용이 발생하기 때문에, 전체적인 Cost를 아낄 수 있다.</li><li>Amazon S3 : 파일서버의 역할을 하는 서비스, 일반적인 파일 서버는 트래픽이 증가함에 따라서 장비를 증설하는 작업을 해야하는데 S3는 이와 같은 것을 대행한다. 저장할 수 있는 파일 갯수의 제한이 없으며, 데이터 손실이 발생할 경우 자동으로 복구하며, 정보에 중요도에 따라 보호 수준을 설정해 비용을 절감 할 수 있다.</li></ul></li></ul><h1 id="aws-사용-모범-사례">AWS 사용 모범 사례</h1><ul><li>EC2 모범사례<ul><li>보안 및 네트워크 : 자격증명 연동 및 IAM 역할을 사용해서 리소스 및 API 액세스를 관리한다.</li><li>스토리지: 운영체제에 대해 별도의 EBS 볼륨을 사용하고, 임시데이터를 저장할 수 있는 인스턴스 스토어를 사용한다.</li><li>리소스관리, 백업 및 복구: AWS EBS 스냅샷을 이용해 EBS 볼륨을 정기적으로 백업, 개인 AMI를 만들어 추후 인스턴스 시작을 위한 템플릿으로 구성 저장.</li></ul></li><li>RDS 모범 사례<ul><li>메모리, CPU 사용 모니터링 필수</li><li>DB 인스턴스 확장</li><li>DB 작업량이 늘어났을 경우, 프로비저닝 된 IOPS 스토리지로 변환</li><li>RAM을 충분히 할당하여 작업 집합이 메모리에 상주하도록 한다.</li><li>CloudWatch모니터링을 사용하여 DB인스턴스에 대한 측정치를 확인</li></ul></li></ul><h1 id="amazon-ec2-요금">Amazon EC2 요금</h1><ul><li>온디맨드 : 실행하는 인스턴스에 따라 시간당 혹은 초당 비용 지불<ul><li>유연하고 저렴하게 인스턴스를 사용하거나, 단기간 혹은 첫 개발, 시험중인 경우 사용하면 좋다.</li></ul></li><li>스팟 인스턴스 : 입찰 가격을 정해두고 저렴할 때 이용가능<ul><li>시작과 종료시간이 자유롭거나, 컴퓨팅 가격이 매우 쌀 때 수익이 나는 애플리케이션 경우에 사용</li></ul></li><li>예약 인스턴스 : 계약 기간에 따라 60%까지 저렴하게 이용 가능<ul><li>수요가 꾸준하거나, 예약 용량이 필요할 수 있는 애플리케이션에 사용</li></ul></li></ul><h1 id="amazone-rds">Amazone RDS?</h1><ul><li>아마존 클라우드에서 관계형데이터베이스를 사용할 수 있는 서비스</li><li>DB 관리 작업을 대신해줌 - 각 서버 구성 요소 독립적 확장, 백업 및 복구, 스냅샷 관리 및 보조 인스턴스로 가용성 향상</li><li>각 DB 인스턴스당 Mysql, MariaDB, PostgreSQL, Oracle 등등 엔진 사용가능</li><li>VPC를 사용하여 가상 사설 클라우드에서 인스턴스 실행 가능</li><li>다중 AZ: 데이터 중복 및 장애 조지 지원, 다른 가용 영역에서 자동으로 프로비저닝하고 유지하는 기능</li></ul><h1 id="aws-클라우드에서의-웹-어플리케이션-호스팅">AWS 클라우드에서의 웹 어플리케이션 호스팅</h1><p><img src="../../../../image/2020-02-14-13-54-50.png" alt=""><br><img src="../../../../image/2020-02-14-13-57-12.png" alt=""></p><h1 id="aws-cloudwatch를-사용하여-auto-scaling-인스턴스-및-그룹-모니터링">AWS CloudWatch를 사용하여 Auto Scaling 인스턴스 및 그룹 모니터링</h1><ul><li>모든 EC2 지표 인스턴스를 통계로 사용하여 시스템이 예상대로 수행되는지 확인 가능</li><li>주로 평균 CPU 사용률에 대해 지표를 생성하여 감시하는게 가능</li><li>무료는 5분 단위로 가능, 비용을 더 지불하면 1분 단위로 감시가능</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;영역-1-복원력을-갖춘-아키텍처-설계&quot;&gt;영역 1: 복원력을 갖춘 아키텍처 설계&lt;/h1&gt;
&lt;h1 id=&quot;aws-인프라-구성&quot;&gt;AWS 인프라 구성&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;전 세계 21개의 지리적 리전 내에 66새의 가용영역을 운용&lt;/li&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>language/JavaScript/React</title>
    <link href="https://gurioh.github.io/guriOH.github.io/language/JavaScript/React/"/>
    <id>https://gurioh.github.io/guriOH.github.io/language/JavaScript/React/</id>
    <published>2020-01-31T00:49:18.182Z</published>
    <updated>2020-01-31T06:41:22.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react-context">React Context</h1><p><img src="../../../image/2020-01-31-09-49-20.png" alt=""></p><h1 id="react-redux-flow">React + Redux flow</h1><p><img src="../../../image/2020-01-31-15-41-19.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;react-context&quot;&gt;React Context&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../../image/2020-01-31-09-49-20.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;react-redux-flow&quot;&gt;React +
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Tools/VSCode/shortcut</title>
    <link href="https://gurioh.github.io/guriOH.github.io/Tools/VSCode/shortcut/"/>
    <id>https://gurioh.github.io/guriOH.github.io/Tools/VSCode/shortcut/</id>
    <published>2020-01-27T09:41:05.503Z</published>
    <updated>2020-01-27T10:09:19.321Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../../../image/2020-01-27-18-41-08.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;../../../image/2020-01-27-18-41-08.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SvelteJS</title>
    <link href="https://gurioh.github.io/guriOH.github.io/Framework/Svelte/SvelteJS/"/>
    <id>https://gurioh.github.io/guriOH.github.io/Framework/Svelte/SvelteJS/</id>
    <published>2020-01-23T03:45:02.000Z</published>
    <updated>2020-01-23T03:49:38.072Z</updated>
    
    <content type="html"><![CDATA[<p>기초시작</p><h1 id="컴포넌트-포멧">컴포넌트 포멧</h1><h1 id="템플릿">템플릿</h1><h1 id="attributes-and-props">Attributes and props</h1><h1 id="text-expressions">Text expressions</h1><h1 id="명령어">명령어</h1><h1 id="element-directives">Element directives</h1><h1 id="컴포넌트-이벤트">컴포넌트 이벤트</h1><h1 id="run-time">Run time</h1><h1 id="compile-time">Compile time</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;기초시작&lt;/p&gt;
&lt;h1 id=&quot;컴포넌트-포멧&quot;&gt;컴포넌트 포멧&lt;/h1&gt;
&lt;h1 id=&quot;템플릿&quot;&gt;템플릿&lt;/h1&gt;
&lt;h1 id=&quot;attributes-and-props&quot;&gt;Attributes and props&lt;/h1&gt;
&lt;h1 id=&quot;text-express
      
    
    </summary>
    
    
    
      <category term="Front" scheme="https://gurioh.github.io/guriOH.github.io/tags/Front/"/>
    
      <category term="Framework" scheme="https://gurioh.github.io/guriOH.github.io/tags/Framework/"/>
    
      <category term="JavaScript" scheme="https://gurioh.github.io/guriOH.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>타입스크립트로 리액트 사용하기</title>
    <link href="https://gurioh.github.io/guriOH.github.io/language/JavaScript/TypeScript_01/"/>
    <id>https://gurioh.github.io/guriOH.github.io/language/JavaScript/TypeScript_01/</id>
    <published>2020-01-15T07:42:29.000Z</published>
    <updated>2020-01-26T06:48:37.620Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://gurioh.github.io/guriOH.github.io/tags/JavaScript/"/>
    
      <category term="TypsScript" scheme="https://gurioh.github.io/guriOH.github.io/tags/TypsScript/"/>
    
      <category term="React" scheme="https://gurioh.github.io/guriOH.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>리액트 훅(hook)!</title>
    <link href="https://gurioh.github.io/guriOH.github.io/language/JavaScript/React_hook/"/>
    <id>https://gurioh.github.io/guriOH.github.io/language/JavaScript/React_hook/</id>
    <published>2020-01-15T07:42:29.000Z</published>
    <updated>2020-01-27T05:43:16.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hooks">Hooks</h1><p>리액트 훅은 함수형 컴포넌트에서도 상태관리를 할 수 있는 useState, 렌더링 직후 작업을 설정하는<br>useEffect 등의 기능을 제공하여 기존의 함수형 컴포넌트에서 할 수 없었던 다양한 작업을 할 수 있게 한다.</p><h2 id="usestate">useState</h2><ul><li>함수형 컴포넌트가 가변적인 상태를 갖게 한다.</li></ul><p><img src="../../../image/2020-01-26-15-57-48.png" alt=""></p><ul><li>useState를 Import 하여 사용한다.</li><li>이러한 문법을 배열 비구조화 할당 문법이라고 하나보다… ㅎㅎ</li></ul><h2 id="useeffect">useEffect</h2><ul><li>리액트 컴포넌트가 렌더링 될 떄마다 특정 작업을 수해하도록 설정할 수 있는 Hook이다.</li></ul><p><img src="../../../image/2020-01-26-16-04-24.png" alt=""></p><ul><li>가장 처음 렌더링 됬을때만 실행하고 업데이트 할때는 필요없을 때</li></ul> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">   console.log(&#123;</span><br><span class="line">       value,</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;, []);</span><br></pre></td></tr></table></figure><ul><li>특정 값이 업데이트 됬을 때만 수행. [] 안에 검사할 값을 넣어준다.</li></ul> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">   console.log(&#123;</span><br><span class="line">       value,</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;, [value]);</span><br></pre></td></tr></table></figure><ul><li>컴포넌트가 언마운트 되기 직전 어떤 동작을 수행하고자 할떄</li></ul> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">   console.log(&#123;</span><br><span class="line">       value,</span><br><span class="line">   &#125;);</span><br><span class="line">   return () =&gt; &#123;</span><br><span class="line">     console.log(&apos;cleanup&apos;);</span><br><span class="line">     console.log(value</span><br><span class="line">     );</span><br><span class="line">   &#125;;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><h2 id="usecontext">useContext</h2><ul><li>함수형 컴포넌트에서 Context를 더 쉽게 사용.</li></ul><h2 id="usereducer">useReducer</h2><ul><li>useState 보다 컴포넌트에서 더 다양한 상황에 따라 다양한 상태를 다른 값으로 업데이트해주고 싶을 때 사용하는 Hook</li></ul><h2 id="usememo">useMemo</h2><ul><li>useMemo 를 사용하면 함수형 컴포넌트 내부에서 발생하는 연산을 최적화</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;hooks&quot;&gt;Hooks&lt;/h1&gt;
&lt;p&gt;리액트 훅은 함수형 컴포넌트에서도 상태관리를 할 수 있는 useState, 렌더링 직후 작업을 설정하는&lt;br&gt;
useEffect 등의 기능을 제공하여 기존의 함수형 컴포넌트에서 할 수 없었던 다양한 
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://gurioh.github.io/guriOH.github.io/tags/JavaScript/"/>
    
      <category term="React" scheme="https://gurioh.github.io/guriOH.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Cognito &amp; Web Identity Federation)</title>
    <link href="https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Applications/Cognito/"/>
    <id>https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Applications/Cognito/</id>
    <published>2020-01-15T07:42:29.000Z</published>
    <updated>2020-01-15T13:01:45.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web-identity-federation">Web Identity Federation</h1><ul><li>Web Identity Federation lets you give your users access to AWS resources after they have successfully authenticated with a web-based identify provider like Amazon, Facebook, or Google. Following successful authentication, ther user receives an authentication code from the Web ID provider, which they can trade for temporary AWS security credentials.</li></ul><h1 id="amazon-gognito">Amazon Gognito</h1><ul><li>Amazon Gognito providers Web Identify Federation<ul><li>Sign-up and sign-in to your apps</li><li>Access for guest users</li><li>Acts as an Identify Broker between your application and Web ID providers, so you don’t need to write any additional code.</li><li>Syncronizes user data for multiple devices</li><li>Recommanded for all mobile applications AWS services.</li></ul></li></ul><h1 id="user-pool-identify-pool">User pool &amp; Identify pool</h1><h1 id="tips">Tips</h1><ul><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;web-identity-federation&quot;&gt;Web Identity Federation&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Web Identity Federation lets you give your users access to AWS resour
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Kinesis 101</title>
    <link href="https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Applications/Kinesis101/"/>
    <id>https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Applications/Kinesis101/</id>
    <published>2020-01-15T07:42:29.000Z</published>
    <updated>2020-01-15T08:58:59.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="streaming-data">Streaming data</h1><ul><li>Puchases from online stores</li><li>Stock prices</li><li>Game data</li><li>Social network data</li><li>Geospatial data (uber)</li><li>IOT sensor data</li></ul><h1 id="kinesis">Kinesis</h1><ul><li>Kinesis is a platform on aws to send your streaming data to.<br>Kinesis makes it easy to load and analze streaming data, and also providing the abilirty for you to build your own custom applications for you business needs.</li></ul><h1 id="3-different-types">3 different types</h1><ul><li>Kinesis Streams</li><li>Kinesis Firehose</li><li>Kinesis Analytics</li></ul><h1 id="shard">shard</h1><ul><li>5 transactions per second for reads, up to a maxium total data read rate of 2MB per second and up to 1000 records per second for writes, up to a maximum total data write rate of 1 MB per second (including partition keys)</li></ul><h1 id="tips">Tips</h1><ul><li>Kinesis Streams</li><li>Kinesis Firehose</li><li>Kinesis Analytics</li><li>shard</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;streaming-data&quot;&gt;Streaming data&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Puchases from online stores&lt;/li&gt;
&lt;li&gt;Stock prices&lt;/li&gt;
&lt;li&gt;Game data&lt;/li&gt;
&lt;li&gt;Social ne
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Simple Notification Service</title>
    <link href="https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Applications/SNS/"/>
    <id>https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Applications/SNS/</id>
    <published>2020-01-15T07:42:29.000Z</published>
    <updated>2020-01-15T08:23:52.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sns">SNS</h1><p>SNS is web service that makes easy to set up, operate, and send notification from the cloud.<br>It provides developers with a highly scaleable, flexible, and cost-effective capability to publish message from an application and immediately deliver them to subscribers or other applications.</p><h1 id="sns-benefits">SNS Benefits</h1><ul><li>Instantaneous, push-based delivery (no polling)</li><li>Simple APIs and easy integration with applications</li><li>Flexible message delivery over multiple transport protocols</li><li>Inexpensive, pay-as-you-go model with no up-front costs</li><li>Web-based AWS management Console offers the simplicity of a point-and-click-interface</li></ul><h1 id="sns-vs-sqs">SNS vs SQS</h1><ul><li>Both Messaging Service in AWS</li><li>SNS - Push</li><li>SQS - Polls(Pulls)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sns&quot;&gt;SNS&lt;/h1&gt;
&lt;p&gt;SNS is web service that makes easy to set up, operate, and send notification from the cloud.&lt;br&gt;
It provides develo
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Simple Work Flow Service</title>
    <link href="https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Applications/SWF/"/>
    <id>https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Applications/SWF/</id>
    <published>2020-01-15T07:42:29.000Z</published>
    <updated>2020-01-15T08:14:31.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="swf">SWF</h1><p>SWF is a web service that makes it easy to coordinate work across distributed application components.<br>SWF enables applications for a range of use cases, including media processing, web application back-ends, business process workflows, and analytics pipeliens, to be designed as a coordination of tasks.</p><h1 id="swf-vs-sqs">SWF vs SQS</h1><ul><li>SQS has a retention period of up to 14days, with SWF, workflow executions can last up to 1 year.</li><li>Amozon SWF ensures that a task is assigned only once and is never duplicated. With amazon SQS, you need to handle duplicated message and may also need to ensure that a message is processed only once.</li><li>Amozon SWF keeps track of all the tasks and events in an application. With amazon SQS, you need to implement your own application-level tracking, especially if your application uses multiple queues.</li></ul><h1 id="swf-actors">SWF Actors</h1><ul><li>Workflow Starters</li><li>Deciders : control the flow of activity tasks in a workflow execution.</li><li>Acitivity Workers - Carry out the activity tasks.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;swf&quot;&gt;SWF&lt;/h1&gt;
&lt;p&gt;SWF is a web service that makes it easy to coordinate work across distributed application components.&lt;br&gt;
SWF enabl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SQS</title>
    <link href="https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Applications/SQS/"/>
    <id>https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Applications/SQS/</id>
    <published>2020-01-15T07:42:29.000Z</published>
    <updated>2020-01-15T08:01:07.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sqs">SQS</h1><p>SQS is web service that gices you access to a message queue that can be used to store message while waiting for a computer to process them.2</p><h1 id="two-type-queue">Two type queue</h1><ul><li>Standard Queues (default)</li><li>Fifo Queues (Complemet Standard queue)</li></ul><p>Tips</p><ul><li><p>SQS is pull baed, not pushed baed.</p></li><li><p>Messages are 256 kb in size.</p></li><li><p>Message can be kept in the queue from 1 minute to 14 days; the default retnetion period is 4 days.</p></li><li><p>Visibility Time out is the amount of time that the message is invisible in the SQS queue after a reader picks up that message. Provided the job is processed before the visibility time out expires, the message wil then be deleted from the queue.</p></li><li><p>SQS guarantees that your message will be processed at least once.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sqs&quot;&gt;SQS&lt;/h1&gt;
&lt;p&gt;SQS is web service that gices you access to a message queue that can be used to store message while waiting for a c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Application Summary</title>
    <link href="https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Applications/Summary/"/>
    <id>https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Applications/Summary/</id>
    <published>2020-01-15T07:42:29.000Z</published>
    <updated>2020-01-18T07:58:21.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sqs">SQS</h1><ul><li>SQS is a way to decouple hour infrastructure</li><li>SQS is pull based, not pushed based.</li><li>Messages are 256 KB in size.</li><li>Messages can be kept in the queue from 1 minute to 14 days; the default retention period is 4 days.</li><li>Standard SQS and FIFO SQS</li><li>Standard order is not quaranteed and messages can be delivered more than once.</li><li>FIFO order is strictly maintained and messages are delivered only once.</li><li>SQS guarantees that your messages will be processed at least once.</li></ul><h1 id="swf-vs-sqs">SWF vs SQS</h1><ul><li>SQS has retention period of up to 14 days; with SWF, workflow executions can last up to 1 year.</li><li>Amazon SWF presents a task-oriented APi, whereas Amazon SQS offers a message-oriented API.</li><li>Amazon SWF ensures that a task is assigned only once and is never duplicated. With Amazon SQS, you need to handle duplicated messages and may also need to ensure that a message is processed only once.</li><li>Amazon SWF keeps track of all the tasks and events in an application. With Amazon SQS, need to implement your own application-level tracking, especially if your application uses multiple queues.</li></ul><h1 id="swf-actors">SWF actors</h1><ul><li>Workflow starters</li><li>Deciders</li><li>Activity workers</li></ul><h1 id="sns-benefits">SNS Benefits</h1><ul><li>Instantaneous, push-based delivery (no polling)</li><li>Simple APIs and easy integration with applications</li><li>Flexble message delivery over multiple transport protocols</li><li>Inexpensive, pay-as-you-go model with no up-front costs</li><li>Web-based AWS Management Console offers the simplicithy of a point-and-click interface</li></ul><h1 id="sns-vs-sqs">SNS vs SQS</h1><ul><li>Both Messaging service</li><li>SNS - push</li><li>SQS - polls(Pulls)</li></ul><h1 id="elastic-transcoder">Elastic Transcoder</h1><ul><li>Just rememver that elastic transcoder is a media transcoder in the cloud. It converts media files from their original source format in to different formats that will play on smartphones, tablets, PCs etc</li></ul><h1 id="api-gateway">API Gateway</h1><ul><li>Remeber what api gatway is at a high level</li><li>API gateway has caching capabilities to increase performance</li><li>APi gateway is log cost and scales automatically</li><li>You can throttle API Gateway to prevent attacks</li><li>You can log results to CloudWatch</li><li>If you are using Javascript/AJAX that uses multiple domains with API Gateway, ensure that you have enabled CORS on API Gateway</li></ul><h1 id="kinesis">Kinesis</h1><ul><li>Know the difference between kinesis streams and kinesis firehose. you will be geiven scenario quesions and you must choose the most relevant service.</li><li>Understand what kineis Analytic is.</li></ul><h1 id="cognito">Cognito</h1><ul><li>Federation allows users to authenticate with a Web Identity Provider (Google, Facebook, Amazon)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sqs&quot;&gt;SQS&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;SQS is a way to decouple hour infrastructure&lt;/li&gt;
&lt;li&gt;SQS is pull based, not pushed based.&lt;/li&gt;
&lt;li&gt;Messages 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>API Gateway</title>
    <link href="https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Applications/APIGateway/"/>
    <id>https://gurioh.github.io/guriOH.github.io/Cloud/AWS/Applications/APIGateway/</id>
    <published>2020-01-15T07:42:29.000Z</published>
    <updated>2020-01-18T07:36:04.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="api-gateway">API Gateway</h1><ul><li>It is a fully managed service that makes it easy for developers to publish, maintain, monitor, and secure APIs at any scale.</li></ul><h1 id="what-can-api-gateway-do">What can api gateway do?</h1><ul><li>Expose HTTPS endpoints to define RESTful API</li><li>Serverless-ly connect to service like lamda &amp; DynamoDB</li><li>Send each API endpoint to a different target</li><li>Run efficiently with low cost</li><li>Scale effortlessly</li><li>Track and control usage by API key</li><li>Throttle requests to prevent attacks</li><li>Connect to CloudWatch to log all requests for monitorinng</li><li>Maintain multiple versions of your API</li></ul><h1 id="tips">Tips</h1><ul><li>Remeber what api gatway is at a high level</li><li>API gateway has caching capabilities to increase performance</li><li>APi gateway is log cost and scales automatically</li><li>You can throttle API Gateway to prevent attacks</li><li>You can log results to CloudWatch</li><li>If you are using Javascript/AJAX that uses multiple domains with API Gateway, ensure that you have enabled CORS on API Gateway</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;api-gateway&quot;&gt;API Gateway&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;It is a fully managed service that makes it easy for developers to publish, maintain, monitor
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
